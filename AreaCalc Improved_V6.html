<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Area Calculator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: #eef2f3;
      color: #333;
    }
    .container {
      max-width: 1400px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    header {
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    h1 { margin: 0; font-size: 2.5em; color: #2c3e50; }
    .beta-note {
      margin: 10px 0 0;
      font-style: italic;
      color: #7f8c8d;
    }
    .controls, .segments, .diagram, .results {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px 20px;
      margin-bottom: 20px;
    }
    .controls label, .controls select, .controls input {
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .controls select,
    .controls input[type="number"],
    .controls input[type="text"],
    textarea {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
    }
    .controls button,
    .segments button,
    .results button {
      padding: 10px 15px;
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.3s ease;
    }
    .controls button:hover,
    .segments button:hover,
    .results button:hover {
      background: #2980b9;
    }
    .controls button:disabled,
    .segments button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      vertical-align: middle;
    }
    th { background: #f0f0f0; font-size: 0.9em; }
    canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .report h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
      margin-top: 20px;
    }
    textarea {
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .error { border-color: #e74c3c !important; background-color: #fdf2f2 !important; }
    .warning { border-color: #f39c12 !important; background-color: #fef9e7 !important; }

    /* Field group styles for compact inputs */
    .field-group {
      display: flex;
      gap: 4px;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
    }
    .field-group input {
      width: 55px;
      padding: 6px 4px;
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .field-group input.deg-field { width: 60px; }
    .field-group input.min-field,
    .field-group input.sec-field { width: 50px; }
    .field-group input.grads-field { width: 70px; }
    .field-group input.length-field { width: 80px; }
    .field-group input.radius-field { width: 70px; }
    .field-group select {
      padding: 6px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .field-group .field-label {
      font-size: 0.75em;
      color: #7f8c8d;
      margin-left: -2px;
    }

    /* Help tooltips */
    .help-icon {
      display: inline-block;
      width: 18px;
      height: 18px;
      background: #3498db;
      color: #fff;
      border-radius: 50%;
      text-align: center;
      font-size: 12px;
      line-height: 18px;
      cursor: help;
      margin-left: 4px;
      font-weight: bold;
    }
    .help-icon:hover { background: #2980b9; }

    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 280px;
      background-color: #2c3e50;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -140px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.85em;
      line-height: 1.4;
    }
    .tooltip .tooltip-text::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #2c3e50 transparent transparent transparent;
    }
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .error-box {
      background: #fdf2f2;
      border: 1px solid #e74c3c;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #c0392b;
    }
    .error-box ul {
      margin: 5px 0 0 20px;
      padding: 0;
    }
    .warning-box {
      background: #fef9e7;
      border: 1px solid #f39c12;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #9a7b0a;
    }
    .info-box {
      background: #e8f4f8;
      border: 1px solid #3498db;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #2980b9;
      font-size: 0.9em;
    }

    .format-hint {
      font-size: 0.75em;
      color: #7f8c8d;
      margin-top: 3px;
    }

    /* Starting bearing row */
    .starting-bearing-row {
      background: #e8f4f8;
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
      align-items: center;
      gap: 10px;
    }
    .starting-bearing-row.visible {
      display: flex;
    }
    .starting-bearing-row label {
      font-weight: 500;
      white-space: nowrap;
    }

    /* Report Styles */
    .print-report-header {
      text-align: center;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    .print-report-header h1 {
      font-size: 1.8em;
      color: #2c3e50;
      margin: 0 0 5px 0;
    }
    .print-report-header h2 {
      font-size: 1.1em;
      color: #7f8c8d;
      margin: 0;
      font-weight: 400;
    }
    .print-meta {
      text-align: right;
      font-size: 0.9em;
      color: #7f8c8d;
      margin-bottom: 15px;
    }
    .print-description {
      background: #f8f9fa;
      border-left: 4px solid #3498db;
      padding: 12px 15px;
      margin: 15px 0;
      font-style: italic;
    }
    .print-summary-box {
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
    }
    .print-summary-box h4 {
      margin: 0 0 12px 0;
      color: #2c3e50;
      font-size: 1.1em;
    }
    .print-summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .print-summary-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px dotted #ddd;
    }
    .print-summary-label {
      color: #7f8c8d;
      font-size: 0.9em;
    }
    .print-summary-value {
      font-weight: 600;
      color: #2c3e50;
    }
    .print-diagram-section {
      text-align: center;
      margin: 20px 0;
    }
    .print-diagram-section img {
      max-width: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .print-diagram-caption {
      font-size: 0.85em;
      color: #7f8c8d;
      margin-top: 8px;
      font-style: italic;
    }
    .print-closed-status {
      background: #eafaf1;
      border: 1px solid #27ae60;
      border-radius: 4px;
      padding: 12px 15px;
      margin: 10px 0;
      color: #1e7e34;
    }
    .print-two-column {
      display: flex;
      gap: 30px;
    }
    .print-column {
      flex: 1;
    }
    .print-footer {
      margin-top: 25px;
      padding-top: 12px;
      border-top: 1px solid #ddd;
      font-size: 0.8em;
      color: #7f8c8d;
    }
    .print-footer-content {
      display: flex;
      justify-content: space-between;
    }

    @media (max-width: 900px) {
      .field-group { flex-wrap: wrap; }
      .print-two-column { flex-direction: column; gap: 0; }
      .print-summary-grid { grid-template-columns: 1fr; }
    }

    /* Print Styles */
    @media print {
      @page { size: A4; margin: 15mm; }
      * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      body { margin: 0; padding: 0; background: #fff !important; font-size: 10pt; }
      .container { width: 100%; max-width: none; margin: 0; padding: 0; box-shadow: none; }
      header, .controls, .segments, .diagram, .beta-note { display: none !important; }
      .results { border: none; margin: 0; padding: 0; background: #fff; }
      .report textarea, .report button, .report h3:first-of-type { display: none !important; }
      .print-report-header { border-bottom: 3px solid #2c3e50; padding-bottom: 15pt; margin-bottom: 15pt; }
      .print-report-header h1 { font-size: 22pt; color: #2c3e50; margin: 0 0 5pt 0; }
      .print-report-header h2 { font-size: 12pt; color: #7f8c8d; margin: 0; }
      .print-meta { font-size: 9pt; color: #7f8c8d; text-align: right; margin-bottom: 10pt; }
      #resultsDisplay h3 { font-size: 12pt; color: #2c3e50; border-bottom: 1.5pt solid #bdc3c7; padding-bottom: 4pt; margin: 18pt 0 10pt 0; page-break-after: avoid; }
      .print-diagram-section { text-align: center; margin: 15pt 0; page-break-inside: avoid; }
      .print-diagram-section img { max-width: 75%; max-height: 280pt; border: 1pt solid #ddd; }
      #resultsDisplay table { width: 100%; border-collapse: collapse; margin: 10pt 0; font-size: 9pt; page-break-inside: avoid; }
      #resultsDisplay table th { background: #2c3e50 !important; color: #fff !important; padding: 8pt 6pt; border: 1pt solid #2c3e50; }
      #resultsDisplay table td { padding: 6pt; border: 0.5pt solid #ddd; }
      #resultsDisplay table tbody tr:nth-child(even) { background: #f8f9fa !important; }
      .warning-box { background: #fef9e7 !important; border: 1.5pt solid #f39c12 !important; page-break-inside: avoid; }
      .print-closed-status { background: #eafaf1 !important; border: 1.5pt solid #27ae60 !important; page-break-inside: avoid; }
      .print-footer { margin-top: 20pt; padding-top: 10pt; border-top: 1pt solid #bdc3c7; font-size: 8pt; }
      .no-break { page-break-inside: avoid; }
      h3 { page-break-after: avoid; }
      .print-summary-box { background: #f8f9fa !important; border: 1pt solid #ddd; page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Area Calculator</h1>
      <p class="beta-note">Test version - message Tom Phillips with any bugs/improvement ideas</p>
    </header>

    <!-- Top Controls -->
    <div class="controls">
      <label for="inputUnit">Distance Unit:</label>
      <select id="inputUnit">
        <option value="Metres" selected>Metres</option>
        <option value="DecimalFeet">Decimal Feet</option>
        <option value="FeetInches">Feet and Inches</option>
        <option value="Links">Links</option>
      </select>

      <label for="bearingType" style="margin-left: 15px;">Bearing Type:</label>
      <select id="bearingType">
        <option value="WholeCircle" selected>Whole Circle (D/M/S)</option>
        <option value="DecimalDegrees">Decimal Degrees</option>
        <option value="Quadrant">Quadrant Bearings</option>
        <option value="Internal">Internal Angles</option>
        <option value="Deflection">Deflection Angles</option>
        <option value="Grads">Grads</option>
      </select>

      <label for="angleInputMode" style="margin-left: 15px;">Mode:</label>
      <select id="angleInputMode">
        <option value="Absolute" selected>Absolute</option>
        <option value="Relative">Relative</option>
      </select>

      <label for="outputArea" style="margin-left: 15px;">Area Unit:</label>
      <select id="outputArea">
        <option value="m2" selected>m²</option>
        <option value="ha">ha</option>
        <option value="acres">acres</option>
        <option value="ft2">ft²</option>
      </select>

      <br><br>
      <label for="numSegments"># Segments:</label>
      <input type="number" id="numSegments" value="4" min="3" max="100" style="width:70px;">
      <button id="setSegmentsBtn">Set Segments</button>
      <button id="recalcBtn">Recalculate</button>
    </div>

    <!-- Segment Input Table -->
    <div class="segments">
      <h3>Survey Segments</h3>

      <!-- Starting bearing for Internal/Deflection angles -->
      <div id="startingBearingRow" class="starting-bearing-row">
        <label>Starting Bearing:</label>
        <div class="field-group">
          <input type="number" id="startBearingDeg" class="deg-field" value="0" placeholder="Deg">
          <span class="field-label">°</span>
          <input type="number" id="startBearingMin" class="min-field" value="0" min="0" max="59" placeholder="Min">
          <span class="field-label">'</span>
          <input type="number" id="startBearingSec" class="sec-field" value="0" min="0" max="59.999" step="0.1" placeholder="Sec">
          <span class="field-label">"</span>
        </div>
        <span class="tooltip">
          <span class="help-icon">?</span>
          <span class="tooltip-text">
            For Internal/Deflection angles, enter the absolute bearing of the first segment (degrees clockwise from North).
          </span>
        </span>
      </div>

      <div id="validationErrors"></div>
      <div id="arcWarning"></div>

      <table id="segmentsTable">
        <thead>
          <tr>
            <th style="width: 40px;">No.</th>
            <th id="bearingHeader">Bearing (D/M/S)</th>
            <th id="lengthHeader">Length</th>
            <th>Radius (m)</th>
            <th style="width: 50px;">Flip</th>
            <th style="width: 40px;">Del</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
      <br>
      <button id="addSegmentBtn">Add Segment</button>
    </div>

    <!-- Diagram -->
    <div class="diagram">
      <h3>Survey Diagram</h3>
      <canvas id="diagramCanvas" width="500" height="500"></canvas>
    </div>

    <!-- Results & Report -->
    <div class="results">
      <div id="resultsDisplay">
        <p style="color: #7f8c8d; font-style: italic;">Enter at least 3 segments and click "Recalculate" to see results.</p>
      </div>
      <div class="report">
        <h3>Plan Description & Measurements</h3>
        <textarea id="planDescription" rows="3" placeholder="Add a brief description of this plan..."></textarea>
        <br>
        <button id="saveResultsBtn">Save Results</button>
        <button id="printPreviewBtn">Print Preview</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ============================================
      // CONSTANTS
      // ============================================
      const TOLERANCE = 1e-6;
      const GRADS_TO_DEGREES = 0.9;
      const LINK_TO_METRES = 0.201168;
      const FEET_TO_METRES = 0.3048;
      const INCH_TO_METRES = 0.0254;

      // ============================================
      // UTILITY: Debounce
      // ============================================
      let debounceTimer = null;
      function debounce(fn, delay = 150) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fn, delay);
      }

      // ============================================
      // DMS FIELD HELPERS
      // ============================================

      /**
       * Convert D/M/S field values to decimal degrees
       * @param {number|string} deg - Degrees (can be negative for deflection)
       * @param {number|string} min - Minutes (0-59)
       * @param {number|string} sec - Seconds (0-59.999)
       * @param {boolean} allowNegative - Whether degrees can be negative
       * @returns {number} Decimal degrees
       */
      function dmsFieldsToDecimal(deg, min, sec, allowNegative = false) {
        const d = parseFloat(deg) || 0;
        const m = parseFloat(min) || 0;
        const s = parseFloat(sec) || 0;

        if (m < 0 || m >= 60) throw new Error(`Minutes must be 0-59. Got: ${m}`);
        if (s < 0 || s >= 60) throw new Error(`Seconds must be 0-59.999. Got: ${s}`);
        if (!allowNegative && d < 0) throw new Error(`Degrees cannot be negative.`);

        const sign = d < 0 ? -1 : 1;
        return sign * (Math.abs(d) + m / 60 + s / 3600);
      }

      /**
       * Convert decimal degrees to D/M/S object
       * @param {number} decimal - Decimal degrees
       * @returns {Object} { deg, min, sec }
       */
      function decimalToDMSFields(decimal) {
        const sign = decimal < 0 ? -1 : 1;
        const abs = Math.abs(decimal);
        const deg = Math.floor(abs);
        const minFloat = (abs - deg) * 60;
        const min = Math.floor(minFloat);
        const sec = ((minFloat - min) * 60);
        return {
          deg: sign * deg,
          min: min,
          sec: parseFloat(sec.toFixed(1))
        };
      }

      /**
       * Convert quadrant fields to decimal degrees (whole circle bearing)
       * @param {string} ns - 'N' or 'S'
       * @param {number} deg - Degrees (0-90)
       * @param {number} min - Minutes
       * @param {number} sec - Seconds
       * @param {string} ew - 'E' or 'W'
       * @returns {number} Whole circle bearing (0-360)
       */
      function quadrantFieldsToDecimal(ns, deg, min, sec, ew) {
        const angle = dmsFieldsToDecimal(deg, min, sec, false);
        if (angle < 0 || angle > 90) {
          throw new Error(`Quadrant angle must be 0-90°. Got: ${angle}°`);
        }
        if (ns === 'N' && ew === 'E') return angle;
        if (ns === 'N' && ew === 'W') return 360 - angle;
        if (ns === 'S' && ew === 'E') return 180 - angle;
        if (ns === 'S' && ew === 'W') return 180 + angle;
        throw new Error('Invalid quadrant');
      }

      /**
       * Convert whole circle bearing to quadrant fields
       * @param {number} bearing - Whole circle bearing (0-360)
       * @returns {Object} { ns, deg, min, sec, ew }
       */
      function decimalToQuadrantFields(bearing) {
        bearing = normalizeBearing(bearing);
        let ns, ew, angle;

        if (bearing <= 90) {
          ns = 'N'; ew = 'E'; angle = bearing;
        } else if (bearing <= 180) {
          ns = 'S'; ew = 'E'; angle = 180 - bearing;
        } else if (bearing <= 270) {
          ns = 'S'; ew = 'W'; angle = bearing - 180;
        } else {
          ns = 'N'; ew = 'W'; angle = 360 - bearing;
        }

        const dms = decimalToDMSFields(angle);
        return { ns, deg: dms.deg, min: dms.min, sec: dms.sec, ew };
      }

      function normalizeBearing(bearing) {
        return ((bearing % 360) + 360) % 360;
      }

      function decimalToDMS(bearing) {
        const dms = decimalToDMSFields(Math.abs(bearing));
        const sign = bearing < 0 ? '-' : '';
        return `${sign}${dms.deg}° ${dms.min}' ${dms.sec.toFixed(1)}"`;
      }

      function decimalToQuadrant(bearing) {
        const q = decimalToQuadrantFields(bearing);
        return `${q.ns}${q.deg}°${q.min}'${q.sec.toFixed(0)}"${q.ew}`;
      }

      // ============================================
      // LENGTH HELPERS
      // ============================================

      function parseLengthFields(fields, inputUnit) {
        switch (inputUnit) {
          case 'Metres':
            const m = parseFloat(fields.m);
            if (isNaN(m) || m <= 0) throw new Error('Invalid length');
            return m;
          case 'DecimalFeet':
            const ft = parseFloat(fields.ft);
            if (isNaN(ft) || ft <= 0) throw new Error('Invalid length');
            return ft * FEET_TO_METRES;
          case 'FeetInches':
            const feet = parseFloat(fields.ft) || 0;
            const inches = parseFloat(fields.in) || 0;
            if (inches >= 12) throw new Error('Inches must be < 12');
            const total = feet * FEET_TO_METRES + inches * INCH_TO_METRES;
            if (total <= 0) throw new Error('Invalid length');
            return total;
          case 'Links':
            const lk = parseFloat(fields.lk);
            if (isNaN(lk) || lk <= 0) throw new Error('Invalid length');
            return lk * LINK_TO_METRES;
          default:
            throw new Error('Unknown unit');
        }
      }

      function metresToLengthFields(metres, inputUnit) {
        switch (inputUnit) {
          case 'Metres':
            return { m: metres.toFixed(3) };
          case 'DecimalFeet':
            return { ft: (metres / FEET_TO_METRES).toFixed(3) };
          case 'FeetInches':
            const totalInches = metres / INCH_TO_METRES;
            const feet = Math.floor(totalInches / 12);
            const inches = (totalInches % 12).toFixed(1);
            return { ft: feet.toString(), in: inches };
          case 'Links':
            return { lk: (metres / LINK_TO_METRES).toFixed(2) };
          default:
            return { m: metres.toFixed(3) };
        }
      }

      // ============================================
      // GEOMETRY FUNCTIONS
      // ============================================

      function computeCoordinates(segments) {
        const points = [{ x: 0, y: 0 }];
        let x = 0, y = 0;
        for (const seg of segments) {
          const rad = seg.bearing * Math.PI / 180;
          x += seg.length_m * Math.sin(rad);
          y += seg.length_m * Math.cos(rad);
          points.push({ x, y });
        }
        return points;
      }

      function computeArea(points) {
        if (points.length < 3) return 0;
        let area = 0;
        const n = points.length;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          area += points[i].x * points[j].y;
          area -= points[j].x * points[i].y;
        }
        return Math.abs(area) / 2;
      }

      function computePerimeter(segments) {
        return segments.reduce((sum, seg) => sum + seg.length_m, 0);
      }

      function computeMisclosure(points) {
        if (points.length < 2) return null;
        const first = points[0];
        const last = points[points.length - 1];
        const dx = first.x - last.x;
        const dy = first.y - last.y;
        const length = Math.hypot(dx, dy);
        if (length < TOLERANCE) return null;
        const bearing = normalizeBearing(Math.atan2(dx, dy) * 180 / Math.PI);
        return { length_m: length, bearing };
      }

      function convertAreaValues(m2) {
        return {
          m2: m2.toFixed(2) + ' m²',
          ft2: (m2 * 10.7639).toFixed(2) + ' ft²',
          ha: (m2 / 10000).toFixed(4) + ' ha',
          acres: (m2 * 0.000247105).toFixed(4) + ' acres',
          perches: (m2 / 25.2929).toFixed(2) + ' perches',
          roods: (m2 / 1011.7141).toFixed(4) + ' roods'
        };
      }

      function convertPerimeterValues(m) {
        return {
          m: m.toFixed(2) + ' m',
          ft: (m * 3.28084).toFixed(2) + ' ft',
          links: (m / LINK_TO_METRES).toFixed(2) + ' links'
        };
      }

      // ============================================
      // DIAGRAM DRAWING
      // ============================================

      function drawDiagram(points, misclosure, options = {}) {
        const { allowFill = true } = options;
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (points.length < 2) {
          ctx.fillStyle = '#7f8c8d';
          ctx.font = '14px Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough points to draw', canvas.width / 2, canvas.height / 2);
          return;
        }

        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);

        const padding = 40;
        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        const scale = Math.min((canvas.width - 2 * padding) / rangeX, (canvas.height - 2 * padding) / rangeY);
        const offsetX = (canvas.width - rangeX * scale) / 2 - minX * scale;
        const offsetY = (canvas.height - rangeY * scale) / 2 + maxY * scale;

        const toCanvas = p => ({ x: p.x * scale + offsetX, y: -p.y * scale + offsetY });
        const cPoints = points.map(toCanvas);

        // Fill polygon if closed
        if (allowFill && points.length >= 3 && !misclosure) {
          ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
          ctx.beginPath();
          ctx.moveTo(cPoints[0].x, cPoints[0].y);
          for (let i = 1; i < cPoints.length; i++) ctx.lineTo(cPoints[i].x, cPoints[i].y);
          ctx.closePath();
          ctx.fill();
        }

        // Draw segments
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cPoints[0].x, cPoints[0].y);
        for (let i = 1; i < cPoints.length; i++) ctx.lineTo(cPoints[i].x, cPoints[i].y);

        if (!misclosure) {
          ctx.closePath();
          ctx.stroke();
        } else {
          ctx.stroke();
          // Misclosure line
          ctx.strokeStyle = '#e74c3c';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cPoints[cPoints.length - 1].x, cPoints[cPoints.length - 1].y);
          ctx.lineTo(cPoints[0].x, cPoints[0].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Vertices
        ctx.fillStyle = '#2c3e50';
        for (const cp of cPoints) {
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Segment numbers
        ctx.fillStyle = '#2980b9';
        ctx.font = 'bold 14px Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let i = 0; i < cPoints.length - 1; i++) {
          const midX = (cPoints[i].x + cPoints[i + 1].x) / 2;
          const midY = (cPoints[i].y + cPoints[i + 1].y) / 2;
          const dx = cPoints[i + 1].x - cPoints[i].x;
          const dy = cPoints[i + 1].y - cPoints[i].y;
          const len = Math.hypot(dx, dy) || 1;
          ctx.fillText((i + 1).toString(), midX - dy / len * 15, midY + dx / len * 15);
        }

        // North arrow
        ctx.save();
        ctx.translate(canvas.width - 30, 30);
        ctx.strokeStyle = '#2c3e50';
        ctx.fillStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 20);
        ctx.lineTo(0, -15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(-5, -5);
        ctx.lineTo(5, -5);
        ctx.closePath();
        ctx.fill();
        ctx.font = 'bold 12px Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('N', 0, -22);
        ctx.restore();
      }

      // ============================================
      // UI: Segment Table
      // ============================================

      const segmentsTableBody = document.querySelector('#segmentsTable tbody');

      function clearSegmentsTable() {
        segmentsTableBody.innerHTML = '';
      }

      function getBearingType() {
        return document.getElementById('bearingType').value;
      }

      function getInputUnit() {
        return document.getElementById('inputUnit').value;
      }

      function getAngleInputMode() {
        return document.getElementById('angleInputMode').value;
      }

      /**
       * Create bearing input fields based on bearing type
       */
      function createBearingInputs(bearingType, defaultValues = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.bearingType = bearingType;

        if (bearingType === 'Grads') {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'grads-field';
          input.placeholder = 'Grads';
          input.step = 'any';
          input.value = defaultValues?.grads ?? '';
          input.addEventListener('input', () => triggerLiveUpdate());
          container.appendChild(input);
          const lbl = document.createElement('span');
          lbl.className = 'field-label';
          lbl.textContent = 'g';
          container.appendChild(lbl);
        } else if (bearingType === 'Quadrant') {
          // NS dropdown
          const nsSelect = document.createElement('select');
          nsSelect.innerHTML = '<option value="N">N</option><option value="S">S</option>';
          nsSelect.value = defaultValues?.ns ?? 'N';
          nsSelect.addEventListener('change', () => triggerLiveUpdate());
          container.appendChild(nsSelect);

          // Deg/Min/Sec
          ['deg', 'min', 'sec'].forEach((field, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = field + '-field';
            input.placeholder = field.charAt(0).toUpperCase() + field.slice(1);
            input.min = 0;
            input.max = field === 'deg' ? 90 : 59;
            input.step = field === 'sec' ? '0.1' : '1';
            input.value = defaultValues?.[field] ?? (i === 0 ? '0' : '0');
            input.addEventListener('input', () => triggerLiveUpdate());
            container.appendChild(input);
            const lbl = document.createElement('span');
            lbl.className = 'field-label';
            lbl.textContent = ['°', "'", '"'][i];
            container.appendChild(lbl);
          });

          // EW dropdown
          const ewSelect = document.createElement('select');
          ewSelect.innerHTML = '<option value="E">E</option><option value="W">W</option>';
          ewSelect.value = defaultValues?.ew ?? 'E';
          ewSelect.addEventListener('change', () => triggerLiveUpdate());
          container.appendChild(ewSelect);
        } else {
          // DMS fields for WholeCircle, DecimalDegrees, Internal, Deflection
          const allowNeg = bearingType === 'Deflection';
          ['deg', 'min', 'sec'].forEach((field, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = field + '-field';
            input.placeholder = field.charAt(0).toUpperCase() + field.slice(1);
            if (field === 'deg') {
              if (!allowNeg) input.min = 0;
            } else {
              input.min = 0;
              input.max = 59;
            }
            input.step = field === 'sec' ? '0.1' : '1';
            input.value = defaultValues?.[field] ?? '0';
            input.addEventListener('input', () => triggerLiveUpdate());
            container.appendChild(input);
            const lbl = document.createElement('span');
            lbl.className = 'field-label';
            lbl.textContent = ['°', "'", '"'][i];
            container.appendChild(lbl);
          });
        }

        return container;
      }

      /**
       * Create length input fields based on unit
       */
      function createLengthInputs(inputUnit, defaultValues = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.inputUnit = inputUnit;

        if (inputUnit === 'FeetInches') {
          const ftInput = document.createElement('input');
          ftInput.type = 'number';
          ftInput.className = 'length-field';
          ftInput.placeholder = 'Ft';
          ftInput.min = 0;
          ftInput.value = defaultValues?.ft ?? '';
          ftInput.addEventListener('input', () => triggerLiveUpdate());
          container.appendChild(ftInput);
          const ftLbl = document.createElement('span');
          ftLbl.className = 'field-label';
          ftLbl.textContent = "'";
          container.appendChild(ftLbl);

          const inInput = document.createElement('input');
          inInput.type = 'number';
          inInput.className = 'length-field';
          inInput.placeholder = 'In';
          inInput.min = 0;
          inInput.max = 11.999;
          inInput.step = '0.1';
          inInput.value = defaultValues?.in ?? '';
          inInput.addEventListener('input', () => triggerLiveUpdate());
          container.appendChild(inInput);
          const inLbl = document.createElement('span');
          inLbl.className = 'field-label';
          inLbl.textContent = '"';
          container.appendChild(inLbl);
        } else {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'length-field';
          input.step = 'any';
          input.min = 0;
          const units = { Metres: 'm', DecimalFeet: 'ft', Links: 'lk' };
          input.placeholder = units[inputUnit] || 'm';
          const key = inputUnit === 'Metres' ? 'm' : inputUnit === 'DecimalFeet' ? 'ft' : 'lk';
          input.value = defaultValues?.[key] ?? '';
          input.addEventListener('input', () => triggerLiveUpdate());
          container.appendChild(input);
          const lbl = document.createElement('span');
          lbl.className = 'field-label';
          lbl.textContent = units[inputUnit] || 'm';
          container.appendChild(lbl);
        }

        return container;
      }

      /**
       * Create radius input
       */
      function createRadiusInput(defaultValue = '') {
        const container = document.createElement('div');
        container.className = 'field-group';
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'radius-field';
        input.placeholder = 'Opt.';
        input.step = 'any';
        input.min = 0;
        input.value = defaultValue;
        input.addEventListener('input', () => {
          checkArcWarnings();
          triggerLiveUpdate();
        });
        container.appendChild(input);
        const lbl = document.createElement('span');
        lbl.className = 'field-label';
        lbl.textContent = 'm';
        container.appendChild(lbl);
        return container;
      }

      /**
       * Get default bearing values for creating a closed square
       */
      function getDefaultBearing(segmentIndex) {
        const bearingType = getBearingType();
        const angleInputMode = getAngleInputMode();

        if (bearingType === 'Internal') {
          return { deg: 90, min: 0, sec: 0 };
        } else if (bearingType === 'Deflection') {
          return { deg: segmentIndex === 0 ? 0 : 90, min: 0, sec: 0 };
        } else if (bearingType === 'Quadrant') {
          const bearings = [
            { ns: 'N', deg: 0, min: 0, sec: 0, ew: 'E' },
            { ns: 'N', deg: 90, min: 0, sec: 0, ew: 'E' },
            { ns: 'S', deg: 0, min: 0, sec: 0, ew: 'E' },
            { ns: 'N', deg: 90, min: 0, sec: 0, ew: 'W' }
          ];
          return bearings[segmentIndex % 4];
        } else if (bearingType === 'Grads') {
          const gradBearings = [0, 100, 200, 300];
          return { grads: gradBearings[segmentIndex % 4] };
        } else {
          if (angleInputMode === 'Relative') {
            return { deg: segmentIndex === 0 ? 0 : 90, min: 0, sec: 0 };
          } else {
            const bearings = [0, 90, 180, 270];
            return { deg: bearings[segmentIndex % 4], min: 0, sec: 0 };
          }
        }
      }

      /**
       * Get default length values
       */
      function getDefaultLength() {
        const unit = getInputUnit();
        switch (unit) {
          case 'Metres': return { m: '10' };
          case 'DecimalFeet': return { ft: '32.81' };
          case 'FeetInches': return { ft: '32', in: '10' };
          case 'Links': return { lk: '49.71' };
          default: return { m: '10' };
        }
      }

      function addSegmentRow(bearingVals = null, lengthVals = null, radiusVal = '') {
        const rowIndex = segmentsTableBody.querySelectorAll('tr').length;
        const bearingType = getBearingType();
        const inputUnit = getInputUnit();

        const row = document.createElement('tr');

        // Segment number
        const cellNo = document.createElement('td');
        cellNo.textContent = (rowIndex + 1).toString();
        row.appendChild(cellNo);

        // Bearing inputs
        const cellBearing = document.createElement('td');
        const bearingDefaults = bearingVals ?? getDefaultBearing(rowIndex);
        cellBearing.appendChild(createBearingInputs(bearingType, bearingDefaults));
        row.appendChild(cellBearing);

        // Length inputs
        const cellLength = document.createElement('td');
        const lengthDefaults = lengthVals ?? getDefaultLength();
        cellLength.appendChild(createLengthInputs(inputUnit, lengthDefaults));
        row.appendChild(cellLength);

        // Radius input
        const cellRadius = document.createElement('td');
        cellRadius.appendChild(createRadiusInput(radiusVal));
        row.appendChild(cellRadius);

        // Flip button
        const cellFlip = document.createElement('td');
        const flipBtn = document.createElement('button');
        flipBtn.textContent = '↔';
        flipBtn.title = 'Flip bearing 180°';
        flipBtn.style.padding = '6px 10px';
        flipBtn.addEventListener('click', () => flipSegment(row));
        cellFlip.appendChild(flipBtn);
        row.appendChild(cellFlip);

        // Delete button
        const cellDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = '✕';
        delBtn.title = 'Delete segment';
        delBtn.style.padding = '6px 10px';
        delBtn.style.background = '#e74c3c';
        delBtn.addEventListener('click', () => {
          row.remove();
          updateSegmentNumbers();
          triggerLiveUpdate();
        });
        cellDel.appendChild(delBtn);
        row.appendChild(cellDel);

        segmentsTableBody.appendChild(row);
        updateSegmentNumbers();
      }

      function updateSegmentNumbers() {
        const rows = segmentsTableBody.querySelectorAll('tr');
        rows.forEach((row, idx) => {
          row.firstChild.textContent = (idx + 1).toString();
        });
      }

      /**
       * Get bearing values from row
       */
      function getBearingFromRow(row) {
        const container = row.children[1].querySelector('.field-group');
        const bearingType = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');

        if (bearingType === 'Grads') {
          return { grads: parseFloat(inputs[0].value) || 0 };
        } else if (bearingType === 'Quadrant') {
          return {
            ns: selects[0].value,
            deg: parseFloat(inputs[0].value) || 0,
            min: parseFloat(inputs[1].value) || 0,
            sec: parseFloat(inputs[2].value) || 0,
            ew: selects[1].value
          };
        } else {
          return {
            deg: parseFloat(inputs[0].value) || 0,
            min: parseFloat(inputs[1].value) || 0,
            sec: parseFloat(inputs[2].value) || 0
          };
        }
      }

      /**
       * Set bearing values in row
       */
      function setBearingInRow(row, values) {
        const container = row.children[1].querySelector('.field-group');
        const bearingType = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');

        if (bearingType === 'Grads') {
          inputs[0].value = values.grads ?? 0;
        } else if (bearingType === 'Quadrant') {
          selects[0].value = values.ns ?? 'N';
          inputs[0].value = values.deg ?? 0;
          inputs[1].value = values.min ?? 0;
          inputs[2].value = values.sec ?? 0;
          selects[1].value = values.ew ?? 'E';
        } else {
          inputs[0].value = values.deg ?? 0;
          inputs[1].value = values.min ?? 0;
          inputs[2].value = values.sec ?? 0;
        }
      }

      /**
       * Get length values from row
       */
      function getLengthFromRow(row) {
        const container = row.children[2].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const unit = container.dataset.inputUnit;

        if (unit === 'FeetInches') {
          return { ft: inputs[0].value, in: inputs[1].value };
        } else {
          const key = unit === 'Metres' ? 'm' : unit === 'DecimalFeet' ? 'ft' : 'lk';
          return { [key]: inputs[0].value };
        }
      }

      /**
       * Get radius value from row
       */
      function getRadiusFromRow(row) {
        const input = row.children[3].querySelector('input');
        return input.value;
      }

      /**
       * Check for arc radius warnings
       */
      function checkArcWarnings() {
        const rows = segmentsTableBody.querySelectorAll('tr');
        let hasRadius = false;
        rows.forEach(row => {
          const radius = getRadiusFromRow(row);
          if (radius && parseFloat(radius) > 0) hasRadius = true;
        });

        const warningDiv = document.getElementById('arcWarning');
        if (hasRadius) {
          warningDiv.innerHTML = '<div class="info-box">⚠️ Arc radius entered but arc geometry not yet supported; segments will be treated as straight lines.</div>';
        } else {
          warningDiv.innerHTML = '';
        }
      }

      // ============================================
      // PARSING: Get decimal values from fields
      // ============================================

      function parseBearingFromRow(row) {
        const container = row.children[1].querySelector('.field-group');
        const bearingType = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');

        if (bearingType === 'Grads') {
          const grads = parseFloat(inputs[0].value);
          if (isNaN(grads)) throw new Error('Invalid grads');
          return grads * GRADS_TO_DEGREES;
        } else if (bearingType === 'Quadrant') {
          return quadrantFieldsToDecimal(
            selects[0].value,
            inputs[0].value,
            inputs[1].value,
            inputs[2].value,
            selects[1].value
          );
        } else {
          const allowNeg = bearingType === 'Deflection';
          return dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, allowNeg);
        }
      }

      function parseLengthFromRow(row) {
        const container = row.children[2].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const unit = container.dataset.inputUnit;

        if (unit === 'FeetInches') {
          return parseLengthFields({ ft: inputs[0].value, in: inputs[1].value }, 'FeetInches');
        } else {
          const key = unit === 'Metres' ? 'm' : unit === 'DecimalFeet' ? 'ft' : 'lk';
          return parseLengthFields({ [key]: inputs[0].value }, unit);
        }
      }

      function parseStartingBearing() {
        const deg = document.getElementById('startBearingDeg').value;
        const min = document.getElementById('startBearingMin').value;
        const sec = document.getElementById('startBearingSec').value;
        return dmsFieldsToDecimal(deg, min, sec, false);
      }

      // ============================================
      // LIVE UPDATE
      // ============================================

      function parseSegmentsPermissive() {
        const bearingType = getBearingType();
        const angleInputMode = getAngleInputMode();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const segments = [];
        let currentBearing = 0;

        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          try {
            currentBearing = parseStartingBearing();
            currentBearing = normalizeBearing(currentBearing);
          } catch (e) {
            return segments;
          }
        }

        for (let idx = 0; idx < rows.length; idx++) {
          const row = rows[idx];
          let bearing, length;

          try {
            const rawBearing = parseBearingFromRow(row);

            if (bearingType === 'Internal') {
              if (idx === 0) {
                bearing = currentBearing;
              } else {
                const deflection = 180 - rawBearing;
                currentBearing = normalizeBearing(currentBearing + deflection);
                bearing = currentBearing;
              }
            } else if (bearingType === 'Deflection') {
              if (idx === 0) {
                bearing = normalizeBearing(currentBearing + rawBearing);
                currentBearing = bearing;
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
                bearing = currentBearing;
              }
            } else if (angleInputMode === 'Relative') {
              if (idx === 0) {
                currentBearing = normalizeBearing(rawBearing);
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
              }
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(rawBearing);
            }
          } catch (e) {
            break;
          }

          try {
            length = parseLengthFromRow(row);
          } catch (e) {
            break;
          }

          segments.push({ bearing, length_m: length });
        }

        return segments;
      }

      function liveUpdateDiagram() {
        const segments = parseSegmentsPermissive();
        const points = computeCoordinates(segments);
        const canClose = segments.length >= 3;
        const misclosure = canClose ? computeMisclosure(points) : { length_m: 1 };
        const allowFill = canClose && !misclosure;
        drawDiagram(points, canClose ? misclosure : null, { allowFill });
      }

      function triggerLiveUpdate() {
        debounce(liveUpdateDiagram, 150);
      }

      // ============================================
      // FLIP SEGMENT
      // ============================================

      function flipSegment(row) {
        const container = row.children[1].querySelector('.field-group');
        const bearingType = container.dataset.bearingType;

        if (bearingType === 'Internal') {
          alert('Flip not supported for Internal angles (they describe shape, not direction).');
          return;
        }

        try {
          let currentDegrees;

          if (bearingType === 'Deflection') {
            // Negate the deflection
            const vals = getBearingFromRow(row);
            const decimal = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, true);
            const flipped = decimalToDMSFields(-decimal);
            setBearingInRow(row, flipped);
          } else if (bearingType === 'Grads') {
            const vals = getBearingFromRow(row);
            const flipped = ((vals.grads + 200) % 400);
            setBearingInRow(row, { grads: flipped.toFixed(2) });
          } else if (bearingType === 'Quadrant') {
            const vals = getBearingFromRow(row);
            currentDegrees = quadrantFieldsToDecimal(vals.ns, vals.deg, vals.min, vals.sec, vals.ew);
            const flipped = normalizeBearing(currentDegrees + 180);
            const newVals = decimalToQuadrantFields(flipped);
            setBearingInRow(row, newVals);
          } else {
            // DMS
            const vals = getBearingFromRow(row);
            currentDegrees = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, false);
            const flipped = normalizeBearing(currentDegrees + 180);
            const newVals = decimalToDMSFields(flipped);
            setBearingInRow(row, newVals);
          }

          triggerLiveUpdate();
        } catch (e) {
          console.error('Flip error:', e);
        }
      }

      // ============================================
      // REBUILD ROWS ON SETTINGS CHANGE
      // ============================================

      function rebuildAllRows() {
        const bearingType = getBearingType();
        const inputUnit = getInputUnit();
        const rows = Array.from(segmentsTableBody.querySelectorAll('tr'));

        // Try to preserve values by converting to metres and decimal degrees
        const savedData = rows.map((row, idx) => {
          let bearingDegrees = null;
          let lengthMetres = null;
          let radius = getRadiusFromRow(row);

          try {
            // Get current bearing as decimal degrees
            const oldContainer = row.children[1].querySelector('.field-group');
            const oldType = oldContainer.dataset.bearingType;
            const inputs = oldContainer.querySelectorAll('input');
            const selects = oldContainer.querySelectorAll('select');

            if (oldType === 'Grads') {
              bearingDegrees = (parseFloat(inputs[0].value) || 0) * GRADS_TO_DEGREES;
            } else if (oldType === 'Quadrant') {
              bearingDegrees = quadrantFieldsToDecimal(
                selects[0].value,
                inputs[0].value, inputs[1].value, inputs[2].value,
                selects[1].value
              );
            } else {
              bearingDegrees = dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, oldType === 'Deflection');
            }
          } catch (e) {
            bearingDegrees = null;
          }

          try {
            lengthMetres = parseLengthFromRow(row);
          } catch (e) {
            lengthMetres = null;
          }

          return { bearingDegrees, lengthMetres, radius };
        });

        // Clear and rebuild
        clearSegmentsTable();

        savedData.forEach((data, idx) => {
          // Convert bearing to new format
          let bearingVals = null;
          if (data.bearingDegrees !== null) {
            if (bearingType === 'Grads') {
              bearingVals = { grads: (data.bearingDegrees / GRADS_TO_DEGREES).toFixed(2) };
            } else if (bearingType === 'Quadrant') {
              bearingVals = decimalToQuadrantFields(data.bearingDegrees);
            } else {
              bearingVals = decimalToDMSFields(data.bearingDegrees);
            }
          }

          // Convert length to new format
          let lengthVals = null;
          if (data.lengthMetres !== null) {
            lengthVals = metresToLengthFields(data.lengthMetres, inputUnit);
          }

          addSegmentRow(bearingVals, lengthVals, data.radius);
        });

        updateHeaders();
        liveUpdateDiagram();
      }

      function updateHeaders() {
        const bearingType = getBearingType();
        const inputUnit = getInputUnit();

        const bearingHeader = document.getElementById('bearingHeader');
        switch (bearingType) {
          case 'Grads': bearingHeader.textContent = 'Bearing (Grads)'; break;
          case 'Quadrant': bearingHeader.textContent = 'Bearing (Quadrant)'; break;
          case 'Internal': bearingHeader.textContent = 'Internal Angle'; break;
          case 'Deflection': bearingHeader.textContent = 'Deflection Angle'; break;
          default: bearingHeader.textContent = 'Bearing (D/M/S)';
        }

        const lengthHeader = document.getElementById('lengthHeader');
        switch (inputUnit) {
          case 'DecimalFeet': lengthHeader.textContent = 'Length (ft)'; break;
          case 'FeetInches': lengthHeader.textContent = 'Length (ft/in)'; break;
          case 'Links': lengthHeader.textContent = 'Length (links)'; break;
          default: lengthHeader.textContent = 'Length (m)';
        }

        // Show/hide starting bearing row
        const startRow = document.getElementById('startingBearingRow');
        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          startRow.classList.add('visible');
        } else {
          startRow.classList.remove('visible');
        }
      }

      // ============================================
      // VALIDATION & RECALCULATE
      // ============================================

      function validateAndParseInputs() {
        const bearingType = getBearingType();
        const angleInputMode = getAngleInputMode();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const errors = [];
        const segments = [];
        let currentBearing = 0;

        // Clear errors
        rows.forEach(row => {
          row.children[1].querySelectorAll('input').forEach(i => i.classList.remove('error'));
          row.children[2].querySelectorAll('input').forEach(i => i.classList.remove('error'));
        });
        document.getElementById('startBearingDeg').classList.remove('error');

        if (rows.length < 3) {
          errors.push('At least 3 segments are required.');
        }

        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          try {
            currentBearing = parseStartingBearing();
            currentBearing = normalizeBearing(currentBearing);
          } catch (e) {
            document.getElementById('startBearingDeg').classList.add('error');
            errors.push(`Starting bearing: ${e.message}`);
          }
        }

        rows.forEach((row, idx) => {
          let bearing, length;
          let valid = true;

          try {
            const rawBearing = parseBearingFromRow(row);

            if (bearingType === 'Internal') {
              if (idx === 0) {
                bearing = currentBearing;
              } else {
                if (rawBearing <= 0 || rawBearing >= 360) {
                  throw new Error('Internal angle must be 0-360°');
                }
                const deflection = 180 - rawBearing;
                currentBearing = normalizeBearing(currentBearing + deflection);
                bearing = currentBearing;
              }
            } else if (bearingType === 'Deflection') {
              if (idx === 0) {
                bearing = normalizeBearing(currentBearing + rawBearing);
                currentBearing = bearing;
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
                bearing = currentBearing;
              }
            } else if (angleInputMode === 'Relative') {
              if (idx === 0) {
                currentBearing = normalizeBearing(rawBearing);
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
              }
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(rawBearing);
            }
          } catch (e) {
            row.children[1].querySelectorAll('input').forEach(i => i.classList.add('error'));
            errors.push(`Segment ${idx + 1} bearing: ${e.message}`);
            valid = false;
          }

          try {
            length = parseLengthFromRow(row);
          } catch (e) {
            row.children[2].querySelectorAll('input').forEach(i => i.classList.add('error'));
            errors.push(`Segment ${idx + 1} length: ${e.message}`);
            valid = false;
          }

          // Check radius warning
          const radius = getRadiusFromRow(row);
          if (radius && parseFloat(radius) > 0) {
            // Already warned via checkArcWarnings
          }

          if (valid) {
            segments.push({ bearing, length_m: length, radius: parseFloat(radius) || 0 });
          }
        });

        return { valid: errors.length === 0 && segments.length === rows.length, segments, errors };
      }

      function recalculate() {
        const errorsDiv = document.getElementById('validationErrors');
        const resultsDiv = document.getElementById('resultsDisplay');
        const result = validateAndParseInputs();

        if (result.errors.length > 0) {
          errorsDiv.innerHTML = `<div class="error-box"><strong>Please fix:</strong><ul>${result.errors.map(e => `<li>${e}</li>`).join('')}</ul></div>`;
          resultsDiv.innerHTML = '<p style="color:#e74c3c;">Cannot calculate - fix errors above.</p>';
          return;
        }

        errorsDiv.innerHTML = '';
        checkArcWarnings();

        const segments = result.segments;
        const points = computeCoordinates(segments);
        const area = computeArea(points);
        const perimeter = computePerimeter(segments);
        const misclosure = computeMisclosure(points);

        drawDiagram(points, misclosure);
        resultsDiv.innerHTML = generateReport(area, perimeter, misclosure, segments);
      }

      // ============================================
      // REPORT GENERATION
      // ============================================

      function generateReport(area, perimeter, misclosure, segments) {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
        const timeStr = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
        const inputUnit = getInputUnit();
        const planDesc = document.getElementById('planDescription').value.trim();

        const areaVals = convertAreaValues(area);
        const perimVals = convertPerimeterValues(perimeter);

        let closureHtml, closureStatus, accuracyRatio = 'N/A';
        if (misclosure) {
          accuracyRatio = perimeter > 0 ? `1:${Math.round(perimeter / misclosure.length_m).toLocaleString()}` : 'N/A';
          closureStatus = 'Open';
          closureHtml = `<div class="warning-box no-break"><strong>⚠ Polygon Does Not Close</strong><br>Misclosure: ${misclosure.length_m.toFixed(4)} m at ${misclosure.bearing.toFixed(2)}°<br>Accuracy: ${accuracyRatio}</div>`;
        } else {
          closureStatus = 'Closed';
          closureHtml = `<div class="print-closed-status no-break"><strong>✓ Polygon is Closed</strong></div>`;
        }

        // Check if any arcs
        const hasArcs = segments.some(s => s.radius > 0);

        let tableRows = '';
        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          const lf = metresToLengthFields(seg.length_m, inputUnit);
          const displayLen = inputUnit === 'FeetInches' ? `${lf.ft}' ${lf.in}"` :
                            inputUnit === 'DecimalFeet' ? `${lf.ft} ft` :
                            inputUnit === 'Links' ? `${lf.lk} lk` : `${lf.m} m`;
          const radiusCol = hasArcs ? `<td>${seg.radius > 0 ? seg.radius.toFixed(2) + ' m*' : '-'}</td>` : '';

          tableRows += `<tr>
            <td>${i + 1}</td>
            <td>${seg.bearing.toFixed(2)}°</td>
            <td>${decimalToDMS(seg.bearing)}</td>
            <td>${decimalToQuadrant(seg.bearing)}</td>
            <td>${seg.length_m.toFixed(3)}</td>
            <td>${displayLen}</td>
            ${radiusCol}
          </tr>`;
        }

        const radiusHeader = hasArcs ? '<th>Radius</th>' : '';
        const arcNote = hasArcs ? '<p style="color:#9a7b0a;font-size:0.9em;">* Arc radius entered but treated as straight line (arc geometry not yet implemented)</p>' : '';

        const canvas = document.getElementById('diagramCanvas');
        const diagramImg = canvas.toDataURL('image/png');

        const descHtml = planDesc ? `<div class="print-description no-break"><strong>Description:</strong> ${planDesc}</div>` : '';

        return `
          <div class="print-report-header"><h1>Area Calculation Report</h1><h2>Survey Traverse Analysis</h2></div>
          <div class="print-meta">Generated: ${dateStr} at ${timeStr}</div>
          ${descHtml}
          <div class="print-summary-box no-break">
            <h4>Summary</h4>
            <div class="print-summary-grid">
              <div class="print-summary-item"><span class="print-summary-label">Area:</span><span class="print-summary-value">${areaVals.m2}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Hectares:</span><span class="print-summary-value">${areaVals.ha}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Perimeter:</span><span class="print-summary-value">${perimVals.m}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Sides:</span><span class="print-summary-value">${segments.length}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Status:</span><span class="print-summary-value">${closureStatus}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Accuracy:</span><span class="print-summary-value">${accuracyRatio}</span></div>
            </div>
          </div>
          <div class="print-diagram-section no-break">
            <img src="${diagramImg}" alt="Survey Diagram">
            <div class="print-diagram-caption">Figure 1: Survey traverse diagram</div>
          </div>
          <h3>Closure Status</h3>
          ${closureHtml}
          <div class="print-two-column no-break">
            <div class="print-column">
              <h3>Area</h3>
              <ul>
                <li><strong>${areaVals.m2}</strong></li>
                <li>${areaVals.ft2}</li>
                <li>${areaVals.ha}</li>
                <li>${areaVals.acres}</li>
              </ul>
            </div>
            <div class="print-column">
              <h3>Perimeter</h3>
              <ul>
                <li><strong>${perimVals.m}</strong></li>
                <li>${perimVals.ft}</li>
                <li>${perimVals.links}</li>
              </ul>
            </div>
          </div>
          <h3>Traverse Schedule</h3>
          <table class="no-break">
            <thead><tr><th>Seg</th><th>Bearing (°)</th><th>Bearing (DMS)</th><th>Quadrant</th><th>Length (m)</th><th>Length (${inputUnit})</th>${radiusHeader}</tr></thead>
            <tbody>${tableRows}</tbody>
          </table>
          ${arcNote}
          <div class="print-footer"><div class="print-footer-content"><span>Area Calculator</span><span>Tom Phillips © ${new Date().getFullYear()}</span></div></div>
        `;
      }

      // ============================================
      // EVENT LISTENERS
      // ============================================

      document.getElementById('setSegmentsBtn').addEventListener('click', () => {
        const num = parseInt(document.getElementById('numSegments').value);
        if (isNaN(num) || num < 3) { alert('Min 3 segments.'); return; }
        if (num > 100) { alert('Max 100 segments.'); return; }
        clearSegmentsTable();
        for (let i = 0; i < num; i++) addSegmentRow();
        updateHeaders();
        liveUpdateDiagram();
      });

      document.getElementById('addSegmentBtn').addEventListener('click', () => {
        addSegmentRow();
        triggerLiveUpdate();
      });

      document.getElementById('recalcBtn').addEventListener('click', recalculate);

      // Starting bearing inputs
      ['startBearingDeg', 'startBearingMin', 'startBearingSec'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => triggerLiveUpdate());
      });

      // Settings changes - rebuild rows
      document.getElementById('bearingType').addEventListener('change', rebuildAllRows);
      document.getElementById('inputUnit').addEventListener('change', rebuildAllRows);
      document.getElementById('angleInputMode').addEventListener('change', () => {
        updateHeaders();
        triggerLiveUpdate();
      });

      document.getElementById('saveResultsBtn').addEventListener('click', () => {
        const content = document.getElementById('resultsDisplay').innerText;
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Area_Report.txt';
        a.click();
        URL.revokeObjectURL(url);
      });

      document.getElementById('printPreviewBtn').addEventListener('click', () => window.print());

      // ============================================
      // INITIALIZATION
      // ============================================

      window.onload = () => {
        document.getElementById('bearingType').value = 'WholeCircle';
        document.getElementById('inputUnit').value = 'Metres';
        document.getElementById('angleInputMode').value = 'Absolute';
        updateHeaders();
        document.getElementById('setSegmentsBtn').click();
      };

    })();
  </script>
</body>
</html>
