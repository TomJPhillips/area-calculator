<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Area Calculator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: #eef2f3;
      color: #333;
    }
    .container {
      max-width: 1500px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    header {
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    h1 { margin: 0; font-size: 2.5em; color: #2c3e50; }
    .beta-note {
      margin: 10px 0 0;
      font-style: italic;
      color: #7f8c8d;
    }
    .controls, .segments, .diagram, .results {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px 20px;
      margin-bottom: 20px;
    }
    .controls label, .controls select, .controls input {
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .controls select,
    .controls input[type="number"],
    .controls input[type="text"],
    textarea {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
    }
    .controls button,
    .segments button,
    .results button {
      padding: 10px 15px;
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.3s ease;
    }
    .controls button:hover,
    .segments button:hover,
    .results button:hover {
      background: #2980b9;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: center;
      vertical-align: middle;
    }
    th {
      background: #2c3e50;
      color: #fff;
      font-size: 0.85em;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    #segmentsTable tbody tr:nth-child(odd) { background: #f9f9f9; }
    #segmentsTable tbody tr:nth-child(even) { background: #fff; }
    #segmentsTable tbody tr:hover { background: #e8f4f8; }
    canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    textarea {
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .error { border-color: #e74c3c !important; background-color: #fdf2f2 !important; }

    .field-group {
      display: flex;
      gap: 3px;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
    }
    .field-group input {
      width: 50px;
      padding: 5px 3px;
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }
    .field-group input.deg-field { width: 55px; }
    .field-group input.min-field,
    .field-group input.sec-field { width: 45px; }
    .field-group input.grads-field { width: 65px; }
    .field-group input.length-field { width: 70px; }
    .field-group input.radius-field { width: 60px; }
    .field-group select {
      padding: 5px 3px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }
    .field-group .field-label {
      font-size: 0.7em;
      color: #7f8c8d;
      margin-left: -1px;
    }
    .curve-select {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
      width: 45px;
    }

    .help-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      background: #3498db;
      color: #fff;
      border-radius: 50%;
      text-align: center;
      font-size: 11px;
      line-height: 16px;
      cursor: help;
      margin-left: 3px;
      font-weight: bold;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 260px;
      background-color: #2c3e50;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 50%;
      margin-left: -130px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.8em;
      line-height: 1.3;
    }
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .error-box {
      background: #fdf2f2;
      border: 1px solid #e74c3c;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #c0392b;
    }
    .error-box ul { margin: 5px 0 0 20px; padding: 0; }
    .warning-box {
      background: #fef9e7;
      border: 1px solid #f39c12;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #9a7b0a;
    }

    .starting-bearing-row {
      background: #e8f4f8;
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
      align-items: center;
      gap: 10px;
    }
    .starting-bearing-row.visible { display: flex; }
    .starting-bearing-row label { font-weight: 500; white-space: nowrap; }

    .print-report-header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 15px; margin-bottom: 20px; }
    .print-report-header h1 { font-size: 1.8em; color: #2c3e50; margin: 0 0 5px 0; }
    .print-report-header h2 { font-size: 1.1em; color: #7f8c8d; margin: 0; font-weight: 400; }
    .print-meta { text-align: right; font-size: 0.9em; color: #7f8c8d; margin-bottom: 15px; }
    .print-description { background: #f8f9fa; border-left: 4px solid #3498db; padding: 12px 15px; margin: 15px 0; font-style: italic; }
    .print-summary-box { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 15px; margin: 15px 0; }
    .print-summary-box h4 { margin: 0 0 12px 0; color: #2c3e50; font-size: 1.1em; }
    .print-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .print-summary-item { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dotted #ddd; }
    .print-summary-label { color: #7f8c8d; font-size: 0.9em; }
    .print-summary-value { font-weight: 600; color: #2c3e50; }
    .print-diagram-section { text-align: center; margin: 20px 0; }
    .print-diagram-section img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
    .print-diagram-caption { font-size: 0.85em; color: #7f8c8d; margin-top: 8px; font-style: italic; }
    .print-closed-status { background: #eafaf1; border: 1px solid #27ae60; border-radius: 4px; padding: 12px 15px; margin: 10px 0; color: #1e7e34; }
    .print-two-column { display: flex; gap: 30px; }
    .print-column { flex: 1; }
    .print-footer { margin-top: 25px; padding-top: 12px; border-top: 1px solid #ddd; font-size: 0.8em; color: #7f8c8d; }
    .print-footer-content { display: flex; justify-content: space-between; }

    .help-section {
      background: #e8f4f8;
      border: 1px solid #3498db;
      border-radius: 6px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    .help-toggle {
      width: 100%;
      padding: 12px 20px;
      background: #3498db;
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 1em;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .help-toggle:hover { background: #2980b9; }
    .help-toggle .arrow { transition: transform 0.3s; }
    .help-toggle.open .arrow { transform: rotate(180deg); }
    .help-content {
      display: none;
      padding: 20px;
      font-size: 0.9em;
      line-height: 1.6;
    }
    .help-content.open { display: block; }
    .help-content h4 { color: #2c3e50; margin: 15px 0 8px 0; border-bottom: 1px solid #bce0ee; padding-bottom: 5px; }
    .help-content h4:first-child { margin-top: 0; }
    .help-content dl { margin: 0; }
    .help-content dt { font-weight: 600; color: #2c3e50; margin-top: 10px; }
    .help-content dd { margin: 3px 0 10px 15px; color: #555; }
    .help-content ul { margin: 5px 0; padding-left: 20px; }
    .help-content li { margin: 5px 0; }
    .help-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    @media (max-width: 800px) { .help-grid { grid-template-columns: 1fr; } }

    .advanced-section {
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
    }
    .advanced-section summary {
      padding: 10px 15px;
      cursor: pointer;
      font-size: 0.9em;
      color: #7f8c8d;
      user-select: none;
    }
    .advanced-section summary:hover { color: #3498db; }
    .advanced-section[open] summary { border-bottom: 1px solid #ddd; color: #2c3e50; }
    .advanced-content { padding: 10px 15px 15px 15px; }

    .drag-handle {
      cursor: grab;
      color: #aaa;
      font-size: 1.2em;
      user-select: none;
      padding: 0 5px;
    }
    .drag-handle:hover { color: #3498db; }
    .drag-handle:active { cursor: grabbing; }
    tr.dragging { opacity: 0.5; background: #e8f4f8; }
    tr.drag-over { border-top: 3px solid #3498db; }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: 600;
      font-size: 1.1em;
      margin: 10px 0;
    }
    .status-badge.closed {
      background: linear-gradient(135deg, #27ae60, #2ecc71);
      color: #fff;
      box-shadow: 0 3px 10px rgba(39, 174, 96, 0.3);
    }
    .status-badge.open {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: #fff;
      box-shadow: 0 3px 10px rgba(231, 76, 60, 0.3);
    }
    .status-badge .icon { font-size: 1.3em; }

    .control-group {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 12px 15px;
      margin-bottom: 12px;
    }
    .control-group-title {
      font-size: 0.8em;
      font-weight: 600;
      color: #7f8c8d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
    }
    .control-group label { margin-right: 5px; }
    .control-group select, .control-group input { margin-right: 15px; }

    .diagram-container {
      position: relative;
      text-align: center;
    }
    .scale-bar {
      position: absolute;
      bottom: 15px;
      left: 20px;
      background: rgba(255,255,255,0.9);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8em;
      color: #2c3e50;
      border: 1px solid #ddd;
    }

    /* Responsive Layout */
    @media (max-width: 1200px) {
      .container { margin: 15px; padding: 15px; }
    }
    @media (max-width: 900px) {
      .help-grid { grid-template-columns: 1fr; }
      .control-group { padding: 10px; }
      .field-group { flex-wrap: wrap; gap: 5px; }
      .field-group input { width: 45px !important; }
      .field-group input.deg-field { width: 50px !important; }
      .field-group input.length-field { width: 60px !important; }
      #diagramCanvas { width: 100% !important; height: auto !important; }
    }
    @media (max-width: 600px) {
      h1 { font-size: 1.8em; }
      .controls, .segments, .diagram, .results { padding: 10px; }
      table { font-size: 0.85em; }
      th, td { padding: 4px 2px; }
      .control-group label { display: block; margin-bottom: 5px; }
      .control-group select, .control-group input { margin-bottom: 8px; }
      button { padding: 8px 12px; font-size: 0.9em; }
      .status-badge { padding: 8px 15px; font-size: 1em; }
    }

    @media print {
      @page { size: A4; margin: 20mm 15mm; }
      * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      body { margin: 0; padding: 0; background: #fff !important; font-size: 10pt; }
      .container { width: 100%; max-width: none; margin: 0; padding: 0; box-shadow: none; }
      header, .controls, .segments, .diagram, .beta-note, .help-section { display: none !important; }
      .results { border: none; margin: 0; padding: 10mm; background: #fff; }
      .report textarea, .report button, .report h3:first-of-type { display: none !important; }
      #resultsDisplay { padding: 0 5mm; }
      #resultsDisplay h3 { margin-top: 15pt; page-break-after: avoid; }
      .traverse-schedule-heading { page-break-before: always; padding-top: 0; }
      #resultsDisplay table { width: 100%; border-collapse: collapse; margin: 10pt 0; font-size: 8pt; page-break-inside: avoid; }
      #resultsDisplay table th { background: #2c3e50 !important; color: #fff !important; padding: 6pt 4pt; }
      #resultsDisplay table td { padding: 5pt; border: 0.5pt solid #ddd; }
      .print-summary-box { background: #f8f9fa !important; page-break-inside: avoid; margin: 10pt 0; }
      .print-diagram-section { page-break-inside: avoid; page-break-after: auto; }
      .print-diagram-section img { max-width: 90%; }
      .print-two-column { page-break-before: auto; margin-top: 10pt; }
      .no-break { page-break-inside: avoid; page-break-after: auto; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Area Calculator</h1>
      <p class="beta-note">Survey polygon area with curve support</p>
    </header>

    <div class="help-section">
      <button class="help-toggle" id="helpToggle">
        <span>ðŸ“– Help & Guide for New Users</span>
        <span class="arrow">â–¼</span>
      </button>
      <div class="help-content" id="helpContent">
        <div class="help-grid">
          <div>
            <h4>Quick Start</h4>
            <ol>
              <li><strong>Enter your segments</strong> - Input the bearing (direction) and length for each boundary line from your title plan</li>
              <li><strong>Watch the diagram</strong> - It updates live as you type so you can see the shape forming</li>
              <li><strong>Check closure</strong> - A closed polygon means your traverse returns to the starting point</li>
              <li><strong>Review results</strong> - Area, perimeter, and accuracy are calculated automatically</li>
              <li><strong>Print/Save</strong> - Use the Print button to create a PDF report</li>
            </ol>

            <h4>Controls Explained</h4>
            <dl>
              <dt>Distance Unit</dt>
              <dd>Choose the unit your title plan uses: Metres, Decimal Feet, Feet/Inches, or Links (historic unit, 1 link = 0.201168m)</dd>

              <dt>Bearing Type</dt>
              <dd><strong>Whole Circle (D/M/S)</strong> - Degrees from North clockwise (0-360Â°), e.g., 90Â° = East<br>
              <strong>Quadrant</strong> - Traditional format like N45Â°E (North, turn 45Â° toward East)<br>
              <strong>Internal Angles</strong> - Angles inside the polygon at each corner<br>
              <strong>Deflection</strong> - Turn angles from the previous line direction</dd>

              <dt>Chord vs Arc</dt>
              <dd>For curved boundaries: <strong>Chord</strong> = straight line distance between curve endpoints; <strong>Arc</strong> = distance along the curve itself</dd>
            </dl>
          </div>

          <div>
            <h4>Segment Table Columns</h4>
            <dl>
              <dt>Bearing</dt>
              <dd>The direction of travel for this segment. Enter in DÂ° M' S" format (degrees, minutes, seconds)</dd>

              <dt>Length/Chord</dt>
              <dd>The distance for this segment. For curves, this is the chord (straight line) length</dd>

              <dt>Radius</dt>
              <dd>For curved boundaries only. Leave blank for straight lines. Enter the arc radius in metres</dd>

              <dt>Curve (L/R)</dt>
              <dd>For curves: <strong>L</strong> = arc bulges Left of the travel direction; <strong>R</strong> = arc bulges Right</dd>

              <dt>Flip (â†”)</dt>
              <dd>Reverses the bearing by 180Â° - useful if you entered a direction backwards</dd>
            </dl>

            <h4>Results Explained</h4>
            <dl>
              <dt>Misclosure</dt>
              <dd>The gap between the end point and start point. Zero (or very small) means the polygon closes properly</dd>

              <dt>Accuracy Ratio</dt>
              <dd>Quality measure like "1:10,000" - means 1 unit of error per 10,000 units travelled. Higher is better. Survey standards typically require at least 1:5,000</dd>

              <dt>Add Closing Line</dt>
              <dd>Calculates and adds a segment to close any gap in your traverse</dd>
            </dl>

            <h4>Export to Google My Maps (KML)</h4>
            <dl>
              <dt>What is KML?</dt>
              <dd>KML (Keyhole Markup Language) is a file format used by Google Maps and Google Earth to display geographic data. You can import your polygon to see it overlaid on aerial imagery.</dd>

              <dt>How to get the starting point coordinates</dt>
              <dd>
                <ol>
                  <li>Open <a href="https://www.google.com/maps" target="_blank">Google Maps</a> in your browser</li>
                  <li>Navigate to the location of your first survey point (corner 1 of your property)</li>
                  <li>Right-click on the exact spot</li>
                  <li>Click the coordinates that appear at the top of the menu (e.g., "-36.8485, 174.7633") - this copies them</li>
                  <li>Paste into the Lat and Long fields (you may need to separate them)</li>
                </ol>
              </dd>

              <dt>How to import into Google My Maps</dt>
              <dd>
                <ol>
                  <li>Click "Export KML" to download the .kml file</li>
                  <li>Go to <a href="https://www.google.com/mymaps" target="_blank">Google My Maps</a></li>
                  <li>Create a new map or open an existing one</li>
                  <li>Click "Import" in the left panel</li>
                  <li>Select your .kml file</li>
                  <li>Your polygon will appear on the map with aerial/satellite imagery!</li>
                </ol>
              </dd>

              <dt>Important notes</dt>
              <dd>
                <ul>
                  <li>This assumes your survey bearings are based on true north. If using magnetic north, there may be a small rotation error.</li>
                  <li>The conversion uses a flat-earth approximation which is accurate for typical property sizes.</li>
                  <li>For best results, ensure your polygon is closed before exporting.</li>
                </ul>
              </dd>
            </dl>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div style="display:flex;flex-wrap:wrap;gap:15px;">
        <div class="control-group" style="flex:1;min-width:280px;">
          <div class="control-group-title">Units & Format</div>
          <label for="inputUnit">Distance:</label>
          <select id="inputUnit">
            <option value="Metres" selected>Metres</option>
            <option value="DecimalFeet">Decimal Feet</option>
            <option value="FeetInches">Feet/Inches</option>
            <option value="Links">Links</option>
          </select>
          <br><br>
          <label for="bearingType">Bearing:</label>
          <select id="bearingType">
            <option value="WholeCircle" selected>Whole Circle (D/M/S)</option>
            <option value="DecimalDegrees">Decimal Degrees</option>
            <option value="Quadrant">Quadrant</option>
            <option value="Internal">Internal Angles</option>
            <option value="Deflection">Deflection Angles</option>
            <option value="Grads">Grads</option>
          </select>
          <br><br>
          <label for="angleInputMode">Mode:</label>
          <select id="angleInputMode">
            <option value="Absolute" selected>Absolute</option>
            <option value="Relative">Relative</option>
          </select>
        </div>

        <div class="control-group" style="flex:1;min-width:280px;">
          <div class="control-group-title">Segments & Closure</div>
          <label for="numSegments"># Segments:</label>
          <input type="number" id="numSegments" value="4" min="3" max="100" style="width:60px;">
          <button id="setSegmentsBtn">Set</button>
          <br><br>
          <label for="closureTolerance">Tolerance:</label>
          <select id="closureTolerance">
            <option value="5000">1:5,000 (Cadastral)</option>
            <option value="10000" selected>1:10,000 (Standard)</option>
            <option value="15000">1:15,000 (High)</option>
            <option value="25000">1:25,000 (Very High)</option>
            <option value="0">No limit</option>
          </select>
          <br><br>
          <button id="addMisclosureBtn">Add Closing Line</button>
          <span class="tooltip"><span class="help-icon">?</span>
            <span class="tooltip-text">Adds a segment with the exact bearing and distance needed to close the polygon.</span>
          </span>
        </div>

        <div class="control-group" style="flex:1;min-width:280px;">
          <div class="control-group-title">Data Management</div>
          <button id="exportJsonBtn">Export Data</button>
          <button id="importJsonBtn">Import Data</button>
          <button id="clearStorageBtn" style="background:#e67e22;">Clear Saved</button>
          <input type="file" id="importFileInput" accept=".json" style="display:none;">

          <details class="advanced-section" style="margin-top:12px;">
            <summary>Export to Google Maps</summary>
            <div class="advanced-content">
              <p style="margin:5px 0;color:#7f8c8d;font-size:0.85em;">Export polygon to view on aerial imagery.</p>
              <label>Lat:</label>
              <input type="text" id="startLat" placeholder="-36.8485" style="width:85px;">
              <label>Long:</label>
              <input type="text" id="startLng" placeholder="174.7633" style="width:85px;">
              <br><br>
              <button id="exportKmlBtn" style="background:#27ae60;">Export KML</button>
            </div>
          </details>
        </div>
      </div>

      <div id="statusBadgeContainer" style="text-align:center;margin-top:15px;">
        <div class="status-badge closed" id="statusBadge">
          <span class="icon">âœ“</span>
          <span id="statusText">Polygon Closed</span>
        </div>
      </div>
    </div>

    <div class="segments">
      <h3>Survey Segments</h3>

      <div id="startingBearingRow" class="starting-bearing-row">
        <label>Starting Bearing:</label>
        <div class="field-group">
          <input type="number" id="startBearingDeg" class="deg-field" value="0" placeholder="Deg">
          <span class="field-label">Â°</span>
          <input type="number" id="startBearingMin" class="min-field" value="0" min="0" max="59" placeholder="Min">
          <span class="field-label">'</span>
          <input type="number" id="startBearingSec" class="sec-field" value="0" min="0" max="59.999" step="0.1" placeholder="Sec">
          <span class="field-label">"</span>
        </div>
      </div>

      <div id="validationErrors"></div>

      <table id="segmentsTable">
        <thead>
          <tr>
            <th style="width:30px;"></th>
            <th style="width:35px;">No.</th>
            <th id="bearingHeader">Bearing (D/M/S)</th>
            <th id="lengthHeader">Length (Chord)
              <select id="lengthType" style="font-size:0.75em;margin-left:5px;">
                <option value="chord" selected>Chord</option>
                <option value="arc">Arc</option>
              </select>
            </th>
            <th>Radius
              <span class="tooltip"><span class="help-icon">?</span>
                <span class="tooltip-text">Arc radius in metres. Leave blank for straight segments.</span>
              </span>
            </th>
            <th>Curve
              <span class="tooltip"><span class="help-icon">?</span>
                <span class="tooltip-text">L = arc bulges Left of chord direction<br>R = arc bulges Right of chord direction<br>Required if radius is set.</span>
              </span>
            </th>
            <th style="width:40px;">Flip</th>
            <th style="width:35px;">Del</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <br>
      <button id="addSegmentBtn">Add Segment</button>
    </div>

    <div class="diagram">
      <h3>Survey Diagram</h3>
      <div class="diagram-container">
        <canvas id="diagramCanvas" width="650" height="550"></canvas>
        <div class="scale-bar" id="scaleBar">Scale: --</div>
      </div>
    </div>

    <div class="results">
      <div id="resultsDisplay">
        <p style="color: #7f8c8d; font-style: italic;">Enter at least 3 segments and click "Recalculate".</p>
      </div>
      <div class="report">
        <h3>Description</h3>
        <textarea id="planDescription" rows="2" placeholder="Plan description..."></textarea>
        <br>
        <button id="saveResultsBtn">Save</button>
        <button id="printPreviewBtn">Print</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ============================================
      // CONSTANTS
      // ============================================
      const TOLERANCE = 1e-6;
      const GRADS_TO_DEGREES = 0.9;
      const LINK_TO_METRES = 0.201168;
      const FEET_TO_METRES = 0.3048;
      const INCH_TO_METRES = 0.0254;

      let debounceTimer = null;
      function debounce(fn, delay = 150) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fn, delay);
      }

      // ============================================
      // DMS HELPERS
      // ============================================
      function dmsFieldsToDecimal(deg, min, sec, allowNegative = false) {
        const d = parseFloat(deg) || 0;
        const m = parseFloat(min) || 0;
        const s = parseFloat(sec) || 0;
        if (m < 0 || m >= 60) throw new Error(`Minutes must be 0-59`);
        if (s < 0 || s >= 60) throw new Error(`Seconds must be 0-59.999`);
        if (!allowNegative && d < 0) throw new Error(`Degrees cannot be negative`);
        const sign = d < 0 ? -1 : 1;
        return sign * (Math.abs(d) + m / 60 + s / 3600);
      }

      function decimalToDMSFields(decimal) {
        const sign = decimal < 0 ? -1 : 1;
        const abs = Math.abs(decimal);
        let deg = Math.floor(abs);
        let minFloat = (abs - deg) * 60;
        let min = Math.floor(minFloat);
        let sec = parseFloat(((minFloat - min) * 60).toFixed(1));

        // Handle rollover from rounding
        if (sec >= 60) {
          sec = 0;
          min++;
        }
        if (min >= 60) {
          min = 0;
          deg++;
        }

        return { deg: sign * deg, min, sec };
      }

      function quadrantFieldsToDecimal(ns, deg, min, sec, ew) {
        const angle = dmsFieldsToDecimal(deg, min, sec, false);
        if (angle < 0 || angle > 90) throw new Error(`Quadrant angle must be 0-90Â°`);
        if (ns === 'N' && ew === 'E') return angle;
        if (ns === 'N' && ew === 'W') return 360 - angle;
        if (ns === 'S' && ew === 'E') return 180 - angle;
        if (ns === 'S' && ew === 'W') return 180 + angle;
        throw new Error('Invalid quadrant');
      }

      function decimalToQuadrantFields(bearing) {
        bearing = normalizeBearing(bearing);
        let ns, ew, angle;
        if (bearing <= 90) { ns = 'N'; ew = 'E'; angle = bearing; }
        else if (bearing <= 180) { ns = 'S'; ew = 'E'; angle = 180 - bearing; }
        else if (bearing <= 270) { ns = 'S'; ew = 'W'; angle = bearing - 180; }
        else { ns = 'N'; ew = 'W'; angle = 360 - bearing; }
        const dms = decimalToDMSFields(angle);
        return { ns, deg: dms.deg, min: dms.min, sec: dms.sec, ew };
      }

      function normalizeBearing(b) { return ((b % 360) + 360) % 360; }

      function decimalToDMS(b) {
        const dms = decimalToDMSFields(Math.abs(b));
        return `${b < 0 ? '-' : ''}${dms.deg}Â° ${dms.min}' ${dms.sec.toFixed(1)}"`;
      }

      function decimalToQuadrant(b) {
        const q = decimalToQuadrantFields(b);
        return `${q.ns}${q.deg}Â°${q.min}'${q.ew}`;
      }

      // ============================================
      // LENGTH HELPERS
      // ============================================
      function parseLengthFields(fields, unit) {
        if (unit === 'Metres') {
          const m = parseFloat(fields.m);
          if (isNaN(m) || m <= 0) throw new Error('Invalid length');
          return m;
        } else if (unit === 'DecimalFeet') {
          const ft = parseFloat(fields.ft);
          if (isNaN(ft) || ft <= 0) throw new Error('Invalid length');
          return ft * FEET_TO_METRES;
        } else if (unit === 'FeetInches') {
          const feet = parseFloat(fields.ft) || 0;
          const inches = parseFloat(fields.in) || 0;
          if (inches >= 12) throw new Error('Inches must be < 12');
          const total = feet * FEET_TO_METRES + inches * INCH_TO_METRES;
          if (total <= 0) throw new Error('Invalid length');
          return total;
        } else if (unit === 'Links') {
          const lk = parseFloat(fields.lk);
          if (isNaN(lk) || lk <= 0) throw new Error('Invalid length');
          return lk * LINK_TO_METRES;
        }
        throw new Error('Unknown unit');
      }

      function metresToLengthFields(m, unit) {
        if (unit === 'Metres') return { m: m.toFixed(3) };
        if (unit === 'DecimalFeet') return { ft: (m / FEET_TO_METRES).toFixed(3) };
        if (unit === 'FeetInches') {
          const ti = m / INCH_TO_METRES;
          return { ft: Math.floor(ti / 12).toString(), in: (ti % 12).toFixed(1) };
        }
        if (unit === 'Links') return { lk: (m / LINK_TO_METRES).toFixed(2) };
        return { m: m.toFixed(3) };
      }

      // ============================================
      // ARC GEOMETRY FUNCTIONS
      // ============================================

      /**
       * Central angle (radians) from chord and radius
       * theta = 2 * asin(c / (2R))
       */
      function arcCentralAngle(chord, radius) {
        const ratio = chord / (2 * radius);
        if (ratio > 1 + TOLERANCE) throw new Error('Chord exceeds diameter');
        return 2 * Math.asin(Math.min(ratio, 1));
      }

      /**
       * Arc length from chord and radius
       * s = R * theta
       */
      function arcLength(chord, radius) {
        const theta = arcCentralAngle(chord, radius);
        return radius * theta;
      }

      /**
       * Circular segment area (area between chord and arc)
       * Aseg = (R^2 / 2) * (theta - sin(theta))
       */
      function circularSegmentArea(chord, radius) {
        const theta = arcCentralAngle(chord, radius);
        return (radius * radius / 2) * (theta - Math.sin(theta));
      }

      /**
       * Convert arc length to chord length
       * Uses Newton-Raphson iteration: given s and R, find c where s = R * 2 * asin(c/(2R))
       */
      function arcLengthToChord(arcLen, radius) {
        if (arcLen <= 0 || radius <= 0) return 0;
        // theta = s / R
        const theta = arcLen / radius;
        if (theta >= Math.PI) throw new Error('Arc length exceeds semicircle');
        // chord = 2R * sin(theta/2)
        return 2 * radius * Math.sin(theta / 2);
      }

      function getLengthType() {
        return document.getElementById('lengthType').value;
      }

      // ============================================
      // GEOMETRY FUNCTIONS
      // ============================================

      function computeCoordinates(segments) {
        const points = [{ x: 0, y: 0 }];
        let x = 0, y = 0;
        for (const seg of segments) {
          const rad = seg.bearing * Math.PI / 180;
          x += seg.chord * Math.sin(rad);
          y += seg.chord * Math.cos(rad);
          points.push({ x, y });
        }
        return points;
      }

      /**
       * Signed shoelace area (positive = counterclockwise, negative = clockwise)
       */
      function computeSignedArea(points) {
        if (points.length < 3) return 0;
        let area = 0;
        const n = points.length;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          area += points[i].x * points[j].y;
          area -= points[j].x * points[i].y;
        }
        return area / 2;
      }

      /**
       * Compute total area accounting for arc segments
       */
      function computeAreaWithArcs(points, segments) {
        const signedChordArea = computeSignedArea(points);

        let arcAdjustment = 0;
        for (const seg of segments) {
          if (seg.radius > 0 && seg.curveDir) {
            const segArea = circularSegmentArea(seg.chord, seg.radius);
            // R = bulge right = add area, L = bulge left = subtract area
            // But this depends on traverse direction. For clockwise traverse:
            // R adds, L subtracts. We'll use sign of chord area to determine.
            if (seg.curveDir === 'R') {
              arcAdjustment += segArea;
            } else if (seg.curveDir === 'L') {
              arcAdjustment -= segArea;
            }
          }
        }

        // If traverse is clockwise (negative signed area), flip adjustment
        if (signedChordArea < 0) {
          arcAdjustment = -arcAdjustment;
        }

        return Math.abs(signedChordArea + arcAdjustment);
      }

      /**
       * Compute perimeter using arc lengths where applicable
       */
      function computePerimeterWithArcs(segments) {
        let total = 0;
        for (const seg of segments) {
          if (seg.radius > 0 && seg.curveDir) {
            total += arcLength(seg.chord, seg.radius);
          } else {
            total += seg.chord;
          }
        }
        return total;
      }

      function computeMisclosure(points) {
        if (points.length < 2) return null;
        const first = points[0], last = points[points.length - 1];
        const dx = first.x - last.x, dy = first.y - last.y;
        const len = Math.hypot(dx, dy);
        // Treat anything under 1mm as closed (accounts for D/M/S rounding)
        if (len < 0.001) return null;
        return { length_m: len, bearing: normalizeBearing(Math.atan2(dx, dy) * 180 / Math.PI) };
      }

      function convertAreaValues(m2) {
        return {
          m2: m2.toFixed(2) + ' mÂ²',
          ft2: (m2 * 10.7639).toFixed(2) + ' ftÂ²',
          ha: (m2 / 10000).toFixed(4) + ' ha',
          acres: (m2 * 0.000247105).toFixed(4) + ' acres'
        };
      }

      function convertPerimeterValues(m) {
        return {
          m: m.toFixed(2) + ' m',
          ft: (m * 3.28084).toFixed(2) + ' ft',
          links: (m / LINK_TO_METRES).toFixed(2) + ' links'
        };
      }

      // ============================================
      // DIAGRAM DRAWING WITH ARCS
      // ============================================

      function drawDiagram(points, segments, misclosure, options = {}) {
        const { allowFill = true } = options;
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid background
        ctx.fillStyle = '#fafafa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#e8e8e8';
        ctx.lineWidth = 1;
        const gridSize = 25;
        for (let x = 0; x <= canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }

        // Update status badge
        updateStatusBadge(misclosure);

        if (points.length < 2) {
          ctx.fillStyle = '#7f8c8d';
          ctx.font = '14px Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough points', canvas.width / 2, canvas.height / 2);
          document.getElementById('scaleBar').textContent = 'Scale: --';
          return;
        }

        const xs = points.map(p => p.x), ys = points.map(p => p.y);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);

        const padding = 60;
        const rangeX = maxX - minX || 1, rangeY = maxY - minY || 1;
        const scale = Math.min((canvas.width - 2 * padding) / rangeX, (canvas.height - 2 * padding) / rangeY);
        const offsetX = (canvas.width - rangeX * scale) / 2 - minX * scale;
        const offsetY = (canvas.height - rangeY * scale) / 2 + maxY * scale;

        // Update scale bar
        updateScaleBar(scale);

        const toCanvas = p => ({ x: p.x * scale + offsetX, y: -p.y * scale + offsetY });
        const cPoints = points.map(toCanvas);

        // Fill polygon (using chord polygon for simplicity)
        if (allowFill && points.length >= 3 && !misclosure) {
          ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
          ctx.beginPath();
          ctx.moveTo(cPoints[0].x, cPoints[0].y);
          for (let i = 1; i < cPoints.length; i++) ctx.lineTo(cPoints[i].x, cPoints[i].y);
          ctx.closePath();
          ctx.fill();
        }

        // Draw segments (lines or arcs)
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;

        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          const p0 = cPoints[i], p1 = cPoints[i + 1];

          if (seg.radius > 0 && seg.curveDir && p1) {
            // Draw arc
            drawArcSegment(ctx, p0, p1, seg.radius * scale, seg.curveDir);
          } else if (p1) {
            // Draw straight line
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
          }
        }

        // Draw misclosure line if not closed
        if (misclosure && cPoints.length > 1) {
          ctx.strokeStyle = '#e74c3c';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cPoints[cPoints.length - 1].x, cPoints[cPoints.length - 1].y);
          ctx.lineTo(cPoints[0].x, cPoints[0].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Vertices
        ctx.fillStyle = '#2c3e50';
        for (const cp of cPoints) {
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Segment labels with dimensions
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let i = 0; i < cPoints.length - 1 && i < segments.length; i++) {
          const p0 = cPoints[i], p1 = cPoints[i + 1];
          const seg = segments[i];
          const midX = (p0.x + p1.x) / 2, midY = (p0.y + p1.y) / 2;
          const dx = p1.x - p0.x, dy = p1.y - p0.y;
          const segLen = Math.hypot(dx, dy) || 1;

          // Offset perpendicular to segment
          const offsetX = -dy / segLen * 18;
          const offsetY = dx / segLen * 18;

          // Segment number (on one side)
          ctx.fillStyle = '#2980b9';
          ctx.font = 'bold 12px Roboto';
          ctx.fillText((i + 1).toString(), midX + offsetX, midY + offsetY);

          // Bearing and length (on other side)
          ctx.fillStyle = '#555';
          ctx.font = '10px Roboto';
          const bearingStr = seg.bearing.toFixed(1) + 'Â°';
          const lengthStr = seg.chord.toFixed(2) + 'm';
          ctx.fillText(bearingStr, midX - offsetX, midY - offsetY - 6);
          ctx.fillText(lengthStr, midX - offsetX, midY - offsetY + 6);
        }

        // North arrow
        ctx.save();
        ctx.translate(canvas.width - 25, 25);
        ctx.strokeStyle = '#2c3e50';
        ctx.fillStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 15);
        ctx.lineTo(0, -10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-4, -2);
        ctx.lineTo(4, -2);
        ctx.closePath();
        ctx.fill();
        ctx.font = 'bold 10px Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('N', 0, -16);
        ctx.restore();
      }

      /**
       * Draw an arc segment between two canvas points
       */
      function drawArcSegment(ctx, p0, p1, scaledRadius, curveDir) {
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        const chordLen = Math.hypot(dx, dy);

        if (chordLen < TOLERANCE || scaledRadius < chordLen / 2 - TOLERANCE) {
          // Fallback to line if geometry invalid
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
          return;
        }

        // Midpoint
        const mx = (p0.x + p1.x) / 2, my = (p0.y + p1.y) / 2;

        // Distance from midpoint to center
        const halfChord = chordLen / 2;
        const h = Math.sqrt(Math.max(0, scaledRadius * scaledRadius - halfChord * halfChord));

        // Unit normal to chord (perpendicular)
        const nx = -dy / chordLen, ny = dx / chordLen;

        // Choose center based on curve direction
        // In canvas coords: +Y is down. L/R relative to travel direction.
        // If curveDir = R, center is to the right of chord direction
        // If curveDir = L, center is to the left
        let cx, cy;
        if (curveDir === 'R') {
          cx = mx + h * nx;
          cy = my + h * ny;
        } else {
          cx = mx - h * nx;
          cy = my - h * ny;
        }

        // Compute angles from center to p0 and p1
        const startAngle = Math.atan2(p0.y - cy, p0.x - cx);
        const endAngle = Math.atan2(p1.y - cy, p1.x - cx);

        // Determine if we should draw counterclockwise
        // For R curves: draw counterclockwise (canvas coords)
        // For L curves: draw clockwise
        const anticlockwise = (curveDir === 'R');

        ctx.beginPath();
        ctx.arc(cx, cy, scaledRadius, startAngle, endAngle, anticlockwise);
        ctx.stroke();
      }

      // ============================================
      // SCALE BAR & STATUS BADGE
      // ============================================

      function updateScaleBar(pixelsPerMetre) {
        const scaleBar = document.getElementById('scaleBar');
        if (!scaleBar) return;

        // Calculate a nice round scale value
        const metresPerPixel = 1 / pixelsPerMetre;
        const targetBarWidth = 80; // pixels
        const targetMetres = targetBarWidth * metresPerPixel;

        // Round to a nice value
        let niceMetres;
        if (targetMetres >= 100) niceMetres = Math.round(targetMetres / 50) * 50;
        else if (targetMetres >= 10) niceMetres = Math.round(targetMetres / 5) * 5;
        else if (targetMetres >= 1) niceMetres = Math.round(targetMetres);
        else niceMetres = Math.round(targetMetres * 10) / 10;

        if (niceMetres < 0.1) niceMetres = 0.1;

        const barWidth = niceMetres * pixelsPerMetre;
        scaleBar.innerHTML = `<span style="display:inline-block;width:${barWidth}px;height:4px;background:#2c3e50;margin-right:8px;vertical-align:middle;"></span>${niceMetres}m`;
      }

      function updateStatusBadge(misclosure) {
        const badge = document.getElementById('statusBadge');
        const text = document.getElementById('statusText');
        if (!badge || !text) return;

        if (misclosure) {
          badge.className = 'status-badge open';
          badge.querySelector('.icon').textContent = 'âœ—';
          text.textContent = `Open: ${misclosure.length_m.toFixed(3)}m gap`;
        } else {
          badge.className = 'status-badge closed';
          badge.querySelector('.icon').textContent = 'âœ“';
          text.textContent = 'Polygon Closed';
        }
      }

      // ============================================
      // UI: Segment Table
      // ============================================

      const segmentsTableBody = document.querySelector('#segmentsTable tbody');

      // ============================================
      // DATA PERSISTENCE
      // ============================================

      const STORAGE_KEY = 'areaCalc_savedData_v4';

      function collectAllData() {
        const rows = Array.from(segmentsTableBody.querySelectorAll('tr'));
        const segments = rows.map(row => ({
          bearing: getBearingFromRow(row),
          length: getLengthFromRow(row),
          radius: getRadiusFromRow(row),
          curve: getCurveFromRow(row)
        }));

        return {
          version: 2,
          settings: {
            bearingType: getBearingType(),
            inputUnit: getInputUnit(),
            angleInputMode: getAngleInputMode(),
            lengthType: getLengthType(),
            closureTolerance: document.getElementById('closureTolerance').value
          },
          startingBearing: {
            deg: document.getElementById('startBearingDeg').value,
            min: document.getElementById('startBearingMin').value,
            sec: document.getElementById('startBearingSec').value
          },
          geoReference: {
            lat: document.getElementById('startLat').value,
            lng: document.getElementById('startLng').value
          },
          segments,
          description: document.getElementById('planDescription').value
        };
      }

      function saveToLocalStorage() {
        try {
          const data = collectAllData();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
      }

      function loadFromLocalStorage() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (!saved) return false;
          const data = JSON.parse(saved);
          return restoreData(data);
        } catch (e) {
          console.warn('Could not load from localStorage:', e);
          return false;
        }
      }

      function restoreData(data) {
        if (!data || !data.segments || !Array.isArray(data.segments) || data.segments.length === 0) {
          localStorage.removeItem(STORAGE_KEY);
          return false;
        }

        try {
          // Restore settings
          if (data.settings) {
            document.getElementById('bearingType').value = data.settings.bearingType || 'WholeCircle';
            document.getElementById('inputUnit').value = data.settings.inputUnit || 'Metres';
            document.getElementById('angleInputMode').value = data.settings.angleInputMode || 'Absolute';
            document.getElementById('lengthType').value = data.settings.lengthType || 'chord';
            document.getElementById('closureTolerance').value = data.settings.closureTolerance || '10000';
          }

          // Restore starting bearing
          if (data.startingBearing) {
            document.getElementById('startBearingDeg').value = data.startingBearing.deg || 0;
            document.getElementById('startBearingMin').value = data.startingBearing.min || 0;
            document.getElementById('startBearingSec').value = data.startingBearing.sec || 0;
          }

          // Restore geo reference (for KML export)
          if (data.geoReference) {
            document.getElementById('startLat').value = data.geoReference.lat || '';
            document.getElementById('startLng').value = data.geoReference.lng || '';
          }

          // Restore description
          if (data.description) {
            document.getElementById('planDescription').value = data.description;
          }

          // Restore segments
          updateHeaders();
          clearSegmentsTable();
          for (const seg of data.segments) {
            addSegmentRow(seg.bearing, seg.length, seg.radius || '', seg.curve || '');
          }

          liveUpdateDiagram();
          return true;
        } catch (e) {
          console.error('Error restoring data:', e);
          localStorage.removeItem(STORAGE_KEY);
          return false;
        }
      }

      function exportToJson() {
        const data = collectAllData();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const desc = document.getElementById('planDescription').value.trim();
        const filename = desc ? desc.replace(/[^a-z0-9]/gi, '_').substring(0, 30) : 'survey_data';
        a.download = `${filename}.json`;
        a.click();
      }

      function importFromJson(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (restoreData(data)) {
              saveToLocalStorage();
              alert('Data imported successfully!');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Error reading file: ' + err.message);
          }
        };
        reader.readAsText(file);
      }

      function exportToKml() {
        const startLatStr = document.getElementById('startLat').value.trim();
        const startLngStr = document.getElementById('startLng').value.trim();

        if (!startLatStr || !startLngStr) {
          alert('Please enter the starting point latitude and longitude.\n\nTo get coordinates: Right-click on your starting point in Google Maps and click the coordinates to copy them.');
          return;
        }

        const startLat = parseFloat(startLatStr);
        const startLng = parseFloat(startLngStr);

        if (isNaN(startLat) || isNaN(startLng)) {
          alert('Invalid coordinates. Please enter numeric values for latitude and longitude.');
          return;
        }

        if (startLat < -90 || startLat > 90) {
          alert('Latitude must be between -90 and 90.');
          return;
        }

        if (startLng < -180 || startLng > 180) {
          alert('Longitude must be between -180 and 180.');
          return;
        }

        const segments = parseSegmentsPermissive();
        if (segments.length < 3) {
          alert('Need at least 3 valid segments to export a polygon.');
          return;
        }

        const points = computeCoordinates(segments);
        const misclosure = computeMisclosure(points);

        if (misclosure && misclosure.length_m > 1) {
          if (!confirm(`Warning: Polygon is not closed (misclosure: ${misclosure.length_m.toFixed(2)}m).\n\nThe KML will close the polygon automatically. Continue?`)) {
            return;
          }
        }

        // Convert local X/Y coordinates to lat/long
        // X = east (affects longitude), Y = north (affects latitude)
        // Approximation: 1 degree latitude â‰ˆ 111,320 metres
        // 1 degree longitude â‰ˆ 111,320 * cos(latitude) metres
        const METRES_PER_DEG_LAT = 111320;
        const latRad = startLat * Math.PI / 180;
        const metresPerDegLng = METRES_PER_DEG_LAT * Math.cos(latRad);

        const kmlCoords = points.map(p => {
          const lat = startLat + (p.y / METRES_PER_DEG_LAT);
          const lng = startLng + (p.x / metresPerDegLng);
          return `${lng.toFixed(8)},${lat.toFixed(8)},0`;
        });

        // Close the polygon by repeating the first point
        if (kmlCoords.length > 0) {
          kmlCoords.push(kmlCoords[0]);
        }

        const planDesc = document.getElementById('planDescription').value.trim() || 'Survey Polygon';
        const areaM2 = computeAreaWithArcs(points, segments);
        const areaHa = (areaM2 / 10000).toFixed(4);

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${escapeXml(planDesc)}</name>
    <description>Area: ${areaM2.toFixed(2)} mÂ² (${areaHa} ha)
Exported from Area Calculator</description>
    <Style id="surveyPolygonStyle">
      <LineStyle>
        <color>ff0000ff</color>
        <width>3</width>
      </LineStyle>
      <PolyStyle>
        <color>4d0000ff</color>
      </PolyStyle>
    </Style>
    <Placemark>
      <name>${escapeXml(planDesc)}</name>
      <description>Area: ${areaM2.toFixed(2)} mÂ² (${areaHa} ha)</description>
      <styleUrl>#surveyPolygonStyle</styleUrl>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              ${kmlCoords.join('\n              ')}
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
  </Document>
</kml>`;

        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const filename = planDesc.replace(/[^a-z0-9]/gi, '_').substring(0, 30) || 'survey_polygon';
        a.download = `${filename}.kml`;
        a.click();
      }

      function escapeXml(str) {
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&apos;');
      }

      function clearSegmentsTable() { segmentsTableBody.innerHTML = ''; }

      function getBearingType() { return document.getElementById('bearingType').value; }
      function getInputUnit() { return document.getElementById('inputUnit').value; }
      function getAngleInputMode() { return document.getElementById('angleInputMode').value; }

      function createBearingInputs(bearingType, defaults = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.bearingType = bearingType;

        if (bearingType === 'Grads') {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'grads-field';
          input.placeholder = 'Grads';
          input.step = 'any';
          input.value = defaults?.grads ?? '';
          input.addEventListener('input', triggerLiveUpdate);
          container.appendChild(input);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: 'g' }));
        } else if (bearingType === 'Quadrant') {
          const nsSelect = document.createElement('select');
          nsSelect.innerHTML = '<option value="N">N</option><option value="S">S</option>';
          nsSelect.value = defaults?.ns ?? 'N';
          nsSelect.addEventListener('change', triggerLiveUpdate);
          container.appendChild(nsSelect);

          ['deg', 'min', 'sec'].forEach((f, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = f + '-field';
            input.min = 0;
            input.max = f === 'deg' ? 90 : 59;
            input.step = f === 'sec' ? '0.1' : '1';
            input.value = defaults?.[f] ?? '0';
            input.addEventListener('input', triggerLiveUpdate);
            container.appendChild(input);
            container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: ['Â°', "'", '"'][i] }));
          });

          const ewSelect = document.createElement('select');
          ewSelect.innerHTML = '<option value="E">E</option><option value="W">W</option>';
          ewSelect.value = defaults?.ew ?? 'E';
          ewSelect.addEventListener('change', triggerLiveUpdate);
          container.appendChild(ewSelect);
        } else {
          const allowNeg = bearingType === 'Deflection';
          ['deg', 'min', 'sec'].forEach((f, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = f + '-field';
            if (f !== 'deg' || !allowNeg) input.min = 0;
            if (f !== 'deg') input.max = 59;
            input.step = f === 'sec' ? '0.1' : '1';
            input.value = defaults?.[f] ?? '0';
            input.addEventListener('input', triggerLiveUpdate);
            container.appendChild(input);
            container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: ['Â°', "'", '"'][i] }));
          });
        }
        return container;
      }

      function createLengthInputs(unit, defaults = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.inputUnit = unit;

        if (unit === 'FeetInches') {
          const ftInput = document.createElement('input');
          ftInput.type = 'number';
          ftInput.className = 'length-field';
          ftInput.placeholder = 'Ft';
          ftInput.min = 0;
          ftInput.value = defaults?.ft ?? '';
          ftInput.addEventListener('input', triggerLiveUpdate);
          container.appendChild(ftInput);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: "'" }));

          const inInput = document.createElement('input');
          inInput.type = 'number';
          inInput.className = 'length-field';
          inInput.placeholder = 'In';
          inInput.min = 0;
          inInput.max = 11.999;
          inInput.step = '0.1';
          inInput.value = defaults?.in ?? '';
          inInput.addEventListener('input', triggerLiveUpdate);
          container.appendChild(inInput);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: '"' }));
        } else {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'length-field';
          input.step = 'any';
          input.min = 0;
          const units = { Metres: 'm', DecimalFeet: 'ft', Links: 'lk' };
          input.placeholder = units[unit] || 'm';
          const key = unit === 'Metres' ? 'm' : unit === 'DecimalFeet' ? 'ft' : 'lk';
          input.value = defaults?.[key] ?? '';
          input.addEventListener('input', triggerLiveUpdate);
          container.appendChild(input);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: units[unit] || 'm' }));
        }
        return container;
      }

      function createRadiusInput(val = '') {
        const container = document.createElement('div');
        container.className = 'field-group';
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'radius-field';
        input.placeholder = '-';
        input.step = 'any';
        input.min = 0;
        input.value = val;
        input.addEventListener('input', triggerLiveUpdate);
        container.appendChild(input);
        container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: 'm' }));
        return container;
      }

      function createCurveSelect(val = '') {
        const select = document.createElement('select');
        select.className = 'curve-select';
        select.innerHTML = '<option value="">-</option><option value="L">L</option><option value="R">R</option>';
        select.value = val;
        select.addEventListener('change', triggerLiveUpdate);
        return select;
      }

      function getDefaultBearing(idx) {
        const bt = getBearingType(), mode = getAngleInputMode();
        if (bt === 'Internal') return { deg: 90, min: 0, sec: 0 };
        if (bt === 'Deflection') return { deg: idx === 0 ? 0 : 90, min: 0, sec: 0 };
        if (bt === 'Quadrant') {
          const b = [{ ns: 'N', deg: 0, ew: 'E' }, { ns: 'N', deg: 90, ew: 'E' }, { ns: 'S', deg: 0, ew: 'E' }, { ns: 'N', deg: 90, ew: 'W' }];
          return { ...b[idx % 4], min: 0, sec: 0 };
        }
        if (bt === 'Grads') return { grads: [0, 100, 200, 300][idx % 4] };
        if (mode === 'Relative') return { deg: idx === 0 ? 0 : 90, min: 0, sec: 0 };
        return { deg: [0, 90, 180, 270][idx % 4], min: 0, sec: 0 };
      }

      function getDefaultLength() {
        const u = getInputUnit();
        if (u === 'Metres') return { m: '10' };
        if (u === 'DecimalFeet') return { ft: '32.81' };
        if (u === 'FeetInches') return { ft: '32', in: '10' };
        if (u === 'Links') return { lk: '49.71' };
        return { m: '10' };
      }

      function addSegmentRow(bearingVals = null, lengthVals = null, radiusVal = '', curveVal = '') {
        const idx = segmentsTableBody.querySelectorAll('tr').length;
        const bt = getBearingType(), unit = getInputUnit();
        const row = document.createElement('tr');
        row.draggable = true;

        // Col 0: Drag handle
        const dragCell = document.createElement('td');
        const dragHandle = document.createElement('span');
        dragHandle.className = 'drag-handle';
        dragHandle.textContent = 'â‹®â‹®';
        dragHandle.title = 'Drag to reorder';
        dragCell.appendChild(dragHandle);
        row.appendChild(dragCell);

        // Drag events
        row.addEventListener('dragstart', handleDragStart);
        row.addEventListener('dragend', handleDragEnd);
        row.addEventListener('dragover', handleDragOver);
        row.addEventListener('dragleave', handleDragLeave);
        row.addEventListener('drop', handleDrop);

        // Col 1: Number
        row.appendChild(Object.assign(document.createElement('td'), { textContent: (idx + 1).toString() }));

        // Col 1: Bearing
        const cellBearing = document.createElement('td');
        cellBearing.appendChild(createBearingInputs(bt, bearingVals ?? getDefaultBearing(idx)));
        row.appendChild(cellBearing);

        // Col 2: Length
        const cellLength = document.createElement('td');
        cellLength.appendChild(createLengthInputs(unit, lengthVals ?? getDefaultLength()));
        row.appendChild(cellLength);

        // Col 3: Radius
        const cellRadius = document.createElement('td');
        cellRadius.appendChild(createRadiusInput(radiusVal));
        row.appendChild(cellRadius);

        // Col 4: Curve direction
        const cellCurve = document.createElement('td');
        cellCurve.appendChild(createCurveSelect(curveVal));
        row.appendChild(cellCurve);

        // Col 5: Flip
        const cellFlip = document.createElement('td');
        const flipBtn = document.createElement('button');
        flipBtn.textContent = 'â†”';
        flipBtn.title = 'Flip 180Â°';
        flipBtn.style.padding = '4px 8px';
        flipBtn.addEventListener('click', () => flipSegment(row));
        cellFlip.appendChild(flipBtn);
        row.appendChild(cellFlip);

        // Col 6: Delete
        const cellDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'âœ•';
        delBtn.style.padding = '4px 8px';
        delBtn.style.background = '#e74c3c';
        delBtn.addEventListener('click', () => { row.remove(); updateSegmentNumbers(); triggerLiveUpdate(); });
        cellDel.appendChild(delBtn);
        row.appendChild(cellDel);

        segmentsTableBody.appendChild(row);
        updateSegmentNumbers();
      }

      function updateSegmentNumbers() {
        segmentsTableBody.querySelectorAll('tr').forEach((row, i) => {
          row.children[1].textContent = (i + 1).toString();
        });
      }

      // ============================================
      // DRAG AND DROP
      // ============================================
      let draggedRow = null;

      function handleDragStart(e) {
        draggedRow = this;
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      }

      function handleDragEnd(e) {
        this.classList.remove('dragging');
        segmentsTableBody.querySelectorAll('tr').forEach(row => {
          row.classList.remove('drag-over');
        });
        draggedRow = null;
      }

      function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        if (this !== draggedRow) {
          this.classList.add('drag-over');
        }
      }

      function handleDragLeave(e) {
        this.classList.remove('drag-over');
      }

      function handleDrop(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        if (draggedRow && this !== draggedRow) {
          const allRows = Array.from(segmentsTableBody.querySelectorAll('tr'));
          const draggedIdx = allRows.indexOf(draggedRow);
          const targetIdx = allRows.indexOf(this);

          if (draggedIdx < targetIdx) {
            this.parentNode.insertBefore(draggedRow, this.nextSibling);
          } else {
            this.parentNode.insertBefore(draggedRow, this);
          }

          updateSegmentNumbers();
          triggerLiveUpdate();
        }
      }

      // Row accessors (column indices: 0=Drag, 1=No, 2=Bearing, 3=Length, 4=Radius, 5=Curve, 6=Flip, 7=Del)
      function getBearingFromRow(row) {
        const container = row.children[2].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') return { grads: parseFloat(inputs[0].value) || 0 };
        if (bt === 'Quadrant') return { ns: selects[0].value, deg: parseFloat(inputs[0].value) || 0, min: parseFloat(inputs[1].value) || 0, sec: parseFloat(inputs[2].value) || 0, ew: selects[1].value };
        return { deg: parseFloat(inputs[0].value) || 0, min: parseFloat(inputs[1].value) || 0, sec: parseFloat(inputs[2].value) || 0 };
      }

      function setBearingInRow(row, vals) {
        const container = row.children[2].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') { inputs[0].value = vals.grads ?? 0; }
        else if (bt === 'Quadrant') { selects[0].value = vals.ns ?? 'N'; inputs[0].value = vals.deg ?? 0; inputs[1].value = vals.min ?? 0; inputs[2].value = vals.sec ?? 0; selects[1].value = vals.ew ?? 'E'; }
        else { inputs[0].value = vals.deg ?? 0; inputs[1].value = vals.min ?? 0; inputs[2].value = vals.sec ?? 0; }
      }

      function getLengthFromRow(row) {
        const container = row.children[3].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        if (u === 'FeetInches') return { ft: inputs[0].value, in: inputs[1].value };
        const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
        return { [key]: inputs[0].value };
      }

      function getRadiusFromRow(row) {
        return row.children[4].querySelector('input').value;
      }

      function getCurveFromRow(row) {
        return row.children[5].querySelector('select').value;
      }

      // ============================================
      // PARSING
      // ============================================

      function parseBearingFromRow(row) {
        const container = row.children[2].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') {
          const g = parseFloat(inputs[0].value);
          if (isNaN(g)) throw new Error('Invalid grads');
          return g * GRADS_TO_DEGREES;
        }
        if (bt === 'Quadrant') return quadrantFieldsToDecimal(selects[0].value, inputs[0].value, inputs[1].value, inputs[2].value, selects[1].value);
        return dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, bt === 'Deflection');
      }

      function parseLengthFromRow(row, radius = 0) {
        const container = row.children[3].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        let lengthM;
        if (u === 'FeetInches') {
          lengthM = parseLengthFields({ ft: inputs[0].value, in: inputs[1].value }, 'FeetInches');
        } else {
          const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
          lengthM = parseLengthFields({ [key]: inputs[0].value }, u);
        }

        // If arc length mode and radius is set, convert arc to chord
        const lengthType = getLengthType();
        if (lengthType === 'arc' && radius > 0) {
          return arcLengthToChord(lengthM, radius);
        }
        return lengthM;
      }

      function getRawLengthFromRow(row) {
        // Get raw length value without arc-to-chord conversion (for audit trail)
        const container = row.children[3].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        if (u === 'FeetInches') {
          return parseLengthFields({ ft: inputs[0].value, in: inputs[1].value }, 'FeetInches');
        }
        const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
        return parseLengthFields({ [key]: inputs[0].value }, u);
      }

      function parseStartingBearing() {
        return dmsFieldsToDecimal(
          document.getElementById('startBearingDeg').value,
          document.getElementById('startBearingMin').value,
          document.getElementById('startBearingSec').value, false
        );
      }

      // ============================================
      // LIVE UPDATE
      // ============================================

      function parseSegmentsPermissive() {
        const bt = getBearingType(), mode = getAngleInputMode();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const segments = [];
        let currentBearing = 0;

        if (bt === 'Internal' || bt === 'Deflection') {
          try { currentBearing = normalizeBearing(parseStartingBearing()); }
          catch { return segments; }
        }

        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          let bearing, chord, radius, curveDir;

          try {
            const raw = parseBearingFromRow(row);
            if (bt === 'Internal') {
              bearing = i === 0 ? currentBearing : normalizeBearing(currentBearing + 180 - raw);
              if (i > 0) currentBearing = bearing;
            } else if (bt === 'Deflection') {
              bearing = normalizeBearing(currentBearing + raw);
              currentBearing = bearing;
            } else if (mode === 'Relative') {
              currentBearing = i === 0 ? normalizeBearing(raw) : normalizeBearing(currentBearing + raw);
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(raw);
            }
          } catch { break; }

          radius = parseFloat(getRadiusFromRow(row)) || 0;
          curveDir = getCurveFromRow(row);

          try { chord = parseLengthFromRow(row, radius); } catch { break; }

          // Basic validation for live preview
          if (radius > 0 && chord > 2 * radius + TOLERANCE) break;

          segments.push({ bearing, chord, radius, curveDir });
        }
        return segments;
      }

      function liveUpdateDiagram() {
        const segments = parseSegmentsPermissive();
        const points = computeCoordinates(segments);
        const canClose = segments.length >= 3;
        const misclosure = canClose ? computeMisclosure(points) : { length_m: 1 };
        const allowFill = canClose && !misclosure;
        drawDiagram(points, segments, canClose ? misclosure : null, { allowFill });
      }

      function triggerLiveUpdate() {
        debounce(() => {
          liveUpdateDiagram();
          autoRecalculate();
          saveToLocalStorage();
        }, 150);
      }

      function autoRecalculate() {
        // Silent recalculate using permissive parsing (no error highlighting)
        const segments = parseSegmentsPermissive();
        if (segments.length < 3) return; // Need at least 3 valid segments

        const points = computeCoordinates(segments);
        const perimeter = computePerimeterWithArcs(segments);
        const misclosure = computeMisclosure(points);

        const toleranceLimit = parseInt(document.getElementById('closureTolerance').value);
        let toleranceWarning = null;

        if (misclosure && toleranceLimit > 0) {
          const actualRatio = perimeter / misclosure.length_m;
          if (actualRatio < toleranceLimit) {
            toleranceWarning = {
              expected: `1:${toleranceLimit.toLocaleString()}`,
              actual: `1:${Math.round(actualRatio).toLocaleString()}`,
              misclosure: misclosure.length_m
            };
          }
        }

        const area = computeAreaWithArcs(points, segments);
        const resDiv = document.getElementById('resultsDisplay');
        // Simplified report without audit trail for live updates
        resDiv.innerHTML = generateReport(area, perimeter, misclosure, segments, [], toleranceWarning);
      }

      // ============================================
      // FLIP
      // ============================================

      function flipSegment(row) {
        const container = row.children[2].querySelector('.field-group');
        const bt = container.dataset.bearingType;

        if (bt === 'Internal') {
          alert('Flip not supported for Internal angles');
          return;
        }

        try {
          if (bt === 'Deflection') {
            const vals = getBearingFromRow(row);
            const dec = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, true);
            setBearingInRow(row, decimalToDMSFields(-dec));
          } else if (bt === 'Grads') {
            const vals = getBearingFromRow(row);
            setBearingInRow(row, { grads: ((vals.grads + 200) % 400).toFixed(2) });
          } else if (bt === 'Quadrant') {
            const vals = getBearingFromRow(row);
            const dec = quadrantFieldsToDecimal(vals.ns, vals.deg, vals.min, vals.sec, vals.ew);
            setBearingInRow(row, decimalToQuadrantFields(normalizeBearing(dec + 180)));
          } else {
            const vals = getBearingFromRow(row);
            const dec = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, false);
            setBearingInRow(row, decimalToDMSFields(normalizeBearing(dec + 180)));
          }
          triggerLiveUpdate();
        } catch (e) { console.error('Flip error:', e); }
      }

      // ============================================
      // REBUILD ROWS
      // ============================================

      function rebuildAllRows() {
        const bt = getBearingType(), unit = getInputUnit();
        const rows = Array.from(segmentsTableBody.querySelectorAll('tr'));

        const saved = rows.map(row => {
          let bearingDeg = null, lengthM = null;
          try {
            const oldCont = row.children[2].querySelector('.field-group');
            const oldBt = oldCont.dataset.bearingType;
            const inputs = oldCont.querySelectorAll('input');
            const selects = oldCont.querySelectorAll('select');
            if (oldBt === 'Grads') bearingDeg = (parseFloat(inputs[0].value) || 0) * GRADS_TO_DEGREES;
            else if (oldBt === 'Quadrant') bearingDeg = quadrantFieldsToDecimal(selects[0].value, inputs[0].value, inputs[1].value, inputs[2].value, selects[1].value);
            else bearingDeg = dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, oldBt === 'Deflection');
          } catch { bearingDeg = null; }
          try { lengthM = parseLengthFromRow(row); } catch { lengthM = null; }
          return { bearingDeg, lengthM, radius: getRadiusFromRow(row), curve: getCurveFromRow(row) };
        });

        clearSegmentsTable();

        saved.forEach((d, i) => {
          let bv = null;
          if (d.bearingDeg !== null) {
            if (bt === 'Grads') bv = { grads: (d.bearingDeg / GRADS_TO_DEGREES).toFixed(2) };
            else if (bt === 'Quadrant') bv = decimalToQuadrantFields(d.bearingDeg);
            else bv = decimalToDMSFields(d.bearingDeg);
          }
          let lv = null;
          if (d.lengthM !== null) lv = metresToLengthFields(d.lengthM, unit);
          addSegmentRow(bv, lv, d.radius, d.curve);
        });

        updateHeaders();
        liveUpdateDiagram();
      }

      function updateHeaders() {
        const bt = getBearingType(), unit = getInputUnit();
        const bh = document.getElementById('bearingHeader');
        bh.textContent = bt === 'Grads' ? 'Bearing (Grads)' : bt === 'Quadrant' ? 'Bearing (Quadrant)' : bt === 'Internal' ? 'Internal Angle' : bt === 'Deflection' ? 'Deflection' : 'Bearing (D/M/S)';

        const lh = document.getElementById('lengthHeader');
        const lengthSelect = document.getElementById('lengthType');
        const savedValue = lengthSelect ? lengthSelect.value : 'chord';
        const labelText = unit === 'DecimalFeet' ? 'Length/Chord (ft) ' : unit === 'FeetInches' ? 'Length/Chord (ft/in) ' : unit === 'Links' ? 'Length/Chord (lk) ' : 'Length/Chord (m) ';
        // Recreate the select element since textContent would destroy it
        lh.innerHTML = labelText + '<select id="lengthType" style="font-size:0.75em;margin-left:5px;"><option value="chord">Chord</option><option value="arc">Arc</option></select>';
        document.getElementById('lengthType').value = savedValue;
        document.getElementById('lengthType').addEventListener('change', triggerLiveUpdate);

        const sr = document.getElementById('startingBearingRow');
        sr.classList.toggle('visible', bt === 'Internal' || bt === 'Deflection');
      }

      // ============================================
      // VALIDATION & RECALCULATE
      // ============================================

      function validateAndParseInputs() {
        const bt = getBearingType(), mode = getAngleInputMode();
        const unit = getInputUnit();
        const lengthType = getLengthType();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const errors = [], segments = [], rawInputs = [];
        let currentBearing = 0;

        // Clear errors
        rows.forEach(row => {
          row.children[2].querySelectorAll('input').forEach(i => i.classList.remove('error'));
          row.children[3].querySelectorAll('input').forEach(i => i.classList.remove('error'));
          row.children[4].querySelector('input').classList.remove('error');
          row.children[5].querySelector('select').classList.remove('error');
        });

        if (rows.length < 3) errors.push('At least 3 segments required.');

        // Check for curves in relative/internal/deflection modes
        let hasCurves = false;
        rows.forEach(row => {
          const r = parseFloat(getRadiusFromRow(row)) || 0;
          if (r > 0) hasCurves = true;
        });

        if (hasCurves && (bt === 'Internal' || bt === 'Deflection' || mode === 'Relative')) {
          errors.push('Curves require Absolute bearing mode (not Internal/Deflection/Relative). Break curves into chord segments or switch to Absolute mode.');
        }

        if (bt === 'Internal' || bt === 'Deflection') {
          try { currentBearing = normalizeBearing(parseStartingBearing()); }
          catch (e) {
            document.getElementById('startBearingDeg').classList.add('error');
            errors.push(`Starting bearing: ${e.message}`);
          }
        }

        rows.forEach((row, i) => {
          let bearing, chord, radius, curveDir, rawBearing, rawLength;
          let valid = true;

          // Capture raw bearing input for audit trail
          rawBearing = getBearingFromRow(row);

          try {
            const raw = parseBearingFromRow(row);
            if (bt === 'Internal') {
              bearing = i === 0 ? currentBearing : normalizeBearing(currentBearing + 180 - raw);
              if (i > 0) currentBearing = bearing;
            } else if (bt === 'Deflection') {
              bearing = normalizeBearing(currentBearing + raw);
              currentBearing = bearing;
            } else if (mode === 'Relative') {
              currentBearing = i === 0 ? normalizeBearing(raw) : normalizeBearing(currentBearing + raw);
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(raw);
            }
          } catch (e) {
            row.children[2].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
            errors.push(`Seg ${i + 1} bearing: ${e.message}`);
            valid = false;
          }

          radius = parseFloat(getRadiusFromRow(row)) || 0;
          curveDir = getCurveFromRow(row);

          // Capture raw length for audit trail
          try { rawLength = getRawLengthFromRow(row); } catch { rawLength = 0; }

          try { chord = parseLengthFromRow(row, radius); }
          catch (e) {
            row.children[3].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
            errors.push(`Seg ${i + 1} length: ${e.message}`);
            valid = false;
          }

          // Curve validation
          if (radius > 0) {
            if (!curveDir) {
              row.children[5].querySelector('select').classList.add('error');
              errors.push(`Seg ${i + 1}: Radius set but Curve direction (L/R) missing.`);
              valid = false;
            }
            if (valid && chord > 2 * radius + TOLERANCE) {
              row.children[3].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
              row.children[4].querySelector('input').classList.add('error');
              const lenLabel = lengthType === 'arc' ? 'Arc' : 'Chord';
              errors.push(`Seg ${i + 1}: ${lenLabel} too long for radius (chord ${chord.toFixed(2)}m > diameter ${(2 * radius).toFixed(2)}m).`);
              valid = false;
            }
          } else if (curveDir) {
            // Curve direction set but no radius - just ignore curveDir
            curveDir = '';
          }

          if (valid) {
            segments.push({ bearing, chord, radius, curveDir });
            rawInputs.push({
              bearingType: bt,
              bearingInput: rawBearing,
              lengthType,
              lengthInput: rawLength,
              lengthUnit: unit,
              radius,
              curveDir
            });
          }
        });

        return { valid: errors.length === 0 && segments.length === rows.length, segments, rawInputs, errors };
      }

      function recalculate() {
        const errDiv = document.getElementById('validationErrors');
        const resDiv = document.getElementById('resultsDisplay');
        const result = validateAndParseInputs();

        if (result.errors.length > 0) {
          errDiv.innerHTML = `<div class="error-box"><strong>Fix errors:</strong><ul>${result.errors.map(e => `<li>${e}</li>`).join('')}</ul></div>`;
          resDiv.innerHTML = '<p style="color:#e74c3c;">Cannot calculate.</p>';
          return;
        }

        errDiv.innerHTML = '';

        const segments = result.segments;
        const rawInputs = result.rawInputs;
        const points = computeCoordinates(segments);
        const perimeter = computePerimeterWithArcs(segments);
        const misclosure = computeMisclosure(points);

        // Tolerance check
        const toleranceLimit = parseInt(document.getElementById('closureTolerance').value);
        let toleranceWarning = null;

        if (misclosure && toleranceLimit > 0) {
          const actualRatio = perimeter / misclosure.length_m;
          if (actualRatio < toleranceLimit) {
            toleranceWarning = {
              expected: `1:${toleranceLimit.toLocaleString()}`,
              actual: `1:${Math.round(actualRatio).toLocaleString()}`,
              misclosure: misclosure.length_m
            };
          }
        }

        const area = computeAreaWithArcs(points, segments);

        drawDiagram(points, segments, misclosure);
        resDiv.innerHTML = generateReport(area, perimeter, misclosure, segments, rawInputs, toleranceWarning);
        saveToLocalStorage();
      }

      // ============================================
      // REPORT
      // ============================================

      function formatRawBearing(raw, bearingType) {
        if (bearingType === 'Grads') return `${raw.grads}g`;
        if (bearingType === 'Quadrant') return `${raw.ns}${raw.deg}Â°${raw.min}'${raw.sec}"${raw.ew}`;
        return `${raw.deg}Â°${raw.min}'${raw.sec}"`;
      }

      function generateReport(area, perimeter, misclosure, segments, rawInputs = [], toleranceWarning = null) {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
        const unit = getInputUnit();
        const lengthType = getLengthType();
        const planDesc = document.getElementById('planDescription').value.trim();

        const areaVals = convertAreaValues(area);
        const perimVals = convertPerimeterValues(perimeter);

        let closureHtml, closureStatus, accuracyRatio = 'N/A';
        if (misclosure) {
          accuracyRatio = perimeter > 0 ? `1:${Math.round(perimeter / misclosure.length_m).toLocaleString()}` : 'N/A';
          closureStatus = 'Open';
          closureHtml = `<div class="warning-box no-break"><strong>âš  Polygon Does Not Close</strong><br>Misclosure: ${misclosure.length_m.toFixed(4)} m at ${misclosure.bearing.toFixed(2)}Â°<br>Accuracy: ${accuracyRatio}</div>`;
        } else {
          closureStatus = 'Closed';
          closureHtml = `<div class="print-closed-status no-break"><strong>âœ“ Polygon is Closed</strong></div>`;
        }

        // Tolerance warning
        let toleranceHtml = '';
        if (toleranceWarning) {
          toleranceHtml = `<div class="error-box no-break"><strong>âš  Tolerance Exceeded</strong><br>
            Expected: ${toleranceWarning.expected}<br>
            Actual: ${toleranceWarning.actual}<br>
            Misclosure: ${toleranceWarning.misclosure.toFixed(4)} m<br>
            <em>This traverse does not meet the specified closure tolerance. Check input data or consider using a lower tolerance standard.</em>
          </div>`;
        }

        const hasCurves = segments.some(s => s.radius > 0 && s.curveDir);

        let tableRows = '';
        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          const lf = metresToLengthFields(seg.chord, unit);
          const displayLen = unit === 'FeetInches' ? `${lf.ft}' ${lf.in}"` : unit === 'DecimalFeet' ? `${lf.ft} ft` : unit === 'Links' ? `${lf.lk} lk` : `${lf.m} m`;

          let curveInfo = '';
          if (hasCurves) {
            if (seg.radius > 0 && seg.curveDir) {
              const theta = arcCentralAngle(seg.chord, seg.radius);
              const arcLen = arcLength(seg.chord, seg.radius);
              const deltaD = (theta * 180 / Math.PI).toFixed(2);
              curveInfo = `<td>${seg.radius.toFixed(2)}</td><td>${seg.curveDir}</td><td>${arcLen.toFixed(3)}</td><td>${deltaD}Â°</td>`;
            } else {
              curveInfo = '<td>-</td><td>-</td><td>-</td><td>-</td>';
            }
          }

          tableRows += `<tr>
            <td>${i + 1}</td>
            <td>${seg.bearing.toFixed(2)}Â°</td>
            <td>${decimalToDMS(seg.bearing)}</td>
            <td>${seg.chord.toFixed(3)}</td>
            <td>${displayLen}</td>
            ${curveInfo}
          </tr>`;
        }

        const curveHeaders = hasCurves ? '<th>Radius(m)</th><th>Curve</th><th>Arc Len(m)</th><th>Delta</th>' : '';

        const canvas = document.getElementById('diagramCanvas');
        const diagramImg = canvas.toDataURL('image/png');

        const descHtml = planDesc ? `<div class="print-description no-break"><strong>Description:</strong> ${planDesc}</div>` : '';

        const curveNote = hasCurves ? '<p style="font-size:0.85em;color:#7f8c8d;">* Length column shows chord length for curve segments. Arc length shown separately.</p>' : '';

        return `
          <div class="print-report-header"><h1>Area Calculation Report</h1><h2>Survey Traverse Analysis</h2></div>
          <div class="print-meta">Generated: ${dateStr}</div>
          ${descHtml}
          <div class="print-summary-box no-break">
            <h4>Summary</h4>
            <div class="print-summary-grid">
              <div class="print-summary-item"><span class="print-summary-label">Area:</span><span class="print-summary-value">${areaVals.m2}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Hectares:</span><span class="print-summary-value">${areaVals.ha}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Perimeter:</span><span class="print-summary-value">${perimVals.m}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Sides:</span><span class="print-summary-value">${segments.length}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Status:</span><span class="print-summary-value">${closureStatus}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Accuracy:</span><span class="print-summary-value">${accuracyRatio}</span></div>
            </div>
          </div>
          <div class="print-diagram-section no-break">
            <img src="${diagramImg}" alt="Survey Diagram">
            <div class="print-diagram-caption">Figure 1: Survey traverse${hasCurves ? ' (curves shown as arcs)' : ''}</div>
          </div>
          <h3>Closure Status</h3>
          ${toleranceHtml}
          ${closureHtml}
          <div class="print-two-column no-break">
            <div class="print-column">
              <h3>Area</h3>
              <ul><li><strong>${areaVals.m2}</strong></li><li>${areaVals.ft2}</li><li>${areaVals.ha}</li><li>${areaVals.acres}</li></ul>
            </div>
            <div class="print-column">
              <h3>Perimeter${hasCurves ? ' (using arc lengths)' : ''}</h3>
              <ul><li><strong>${perimVals.m}</strong></li><li>${perimVals.ft}</li><li>${perimVals.links}</li></ul>
            </div>
          </div>
          <h3 class="traverse-schedule-heading">Traverse Schedule</h3>
          <table class="no-break">
            <thead><tr><th>Seg</th><th>Bearing</th><th>DMS</th><th>Chord(m)</th><th>Chord(${unit})</th>${curveHeaders}</tr></thead>
            <tbody>${tableRows}</tbody>
          </table>
          ${curveNote}
          <div class="print-footer"><div class="print-footer-content"><span>Area Calculator</span><span>Tom Phillips Â© ${new Date().getFullYear()}</span></div></div>
        `;
      }

      // ============================================
      // EVENT LISTENERS
      // ============================================

      document.getElementById('setSegmentsBtn').addEventListener('click', () => {
        const num = parseInt(document.getElementById('numSegments').value);
        if (isNaN(num) || num < 3) { alert('Min 3 segments.'); return; }
        if (num > 100) { alert('Max 100 segments.'); return; }
        clearSegmentsTable();
        for (let i = 0; i < num; i++) addSegmentRow();
        updateHeaders();
        liveUpdateDiagram();
      });

      document.getElementById('addSegmentBtn').addEventListener('click', () => {
        addSegmentRow();
        triggerLiveUpdate();
      });

      document.getElementById('addMisclosureBtn').addEventListener('click', () => {
        // Parse current segments to calculate misclosure
        const segments = parseSegmentsPermissive();
        if (segments.length < 2) {
          alert('Need at least 2 valid segments to calculate closing line.');
          return;
        }

        const points = computeCoordinates(segments);
        const misclosure = computeMisclosure(points);

        if (!misclosure) {
          alert('Polygon is already closed!');
          return;
        }

        // The misclosure gives us the bearing and distance needed to close
        const closingBearing = misclosure.bearing;
        const closingLength = misclosure.length_m;

        // Convert bearing to current format
        const bt = getBearingType();
        let bearingVals;
        if (bt === 'Grads') {
          bearingVals = { grads: (closingBearing / GRADS_TO_DEGREES).toFixed(4) };
        } else if (bt === 'Quadrant') {
          bearingVals = decimalToQuadrantFields(closingBearing);
        } else if (bt === 'Internal' || bt === 'Deflection') {
          // For internal/deflection, just use DMS - user will need to adjust
          alert('Closing line added with absolute bearing. Adjust for your angle mode if needed.');
          bearingVals = decimalToDMSFields(closingBearing);
        } else {
          bearingVals = decimalToDMSFields(closingBearing);
        }

        // Convert length to current unit
        const unit = getInputUnit();
        const lengthVals = metresToLengthFields(closingLength, unit);

        // Add the closing segment
        addSegmentRow(bearingVals, lengthVals, '', '');
        triggerLiveUpdate();
      });

      document.getElementById('recalcBtn').addEventListener('click', recalculate);

      ['startBearingDeg', 'startBearingMin', 'startBearingSec'].forEach(id => {
        document.getElementById(id).addEventListener('input', triggerLiveUpdate);
      });

      document.getElementById('bearingType').addEventListener('change', rebuildAllRows);
      document.getElementById('inputUnit').addEventListener('change', rebuildAllRows);
      document.getElementById('angleInputMode').addEventListener('change', () => { updateHeaders(); triggerLiveUpdate(); });

      document.getElementById('saveResultsBtn').addEventListener('click', () => {
        const content = document.getElementById('resultsDisplay').innerText;
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'Area_Report.txt';
        a.click();
      });

      document.getElementById('printPreviewBtn').addEventListener('click', () => window.print());

      // Help toggle
      document.getElementById('helpToggle').addEventListener('click', () => {
        const toggle = document.getElementById('helpToggle');
        const content = document.getElementById('helpContent');
        toggle.classList.toggle('open');
        content.classList.toggle('open');
      });

      // Data persistence buttons
      document.getElementById('exportJsonBtn').addEventListener('click', exportToJson);
      document.getElementById('exportKmlBtn').addEventListener('click', exportToKml);

      document.getElementById('importJsonBtn').addEventListener('click', () => {
        document.getElementById('importFileInput').click();
      });

      document.getElementById('importFileInput').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          importFromJson(e.target.files[0]);
          e.target.value = ''; // Reset for next import
        }
      });

      document.getElementById('clearStorageBtn').addEventListener('click', () => {
        if (confirm('Clear all saved data? This cannot be undone.')) {
          localStorage.removeItem(STORAGE_KEY);
          alert('Saved data cleared.');
        }
      });

      // Length type change triggers live update
      document.getElementById('lengthType').addEventListener('change', triggerLiveUpdate);

      // ============================================
      // INIT
      // ============================================

      window.onload = () => {
        // Try to load from localStorage first
        if (!loadFromLocalStorage()) {
          // No saved data - set defaults
          document.getElementById('bearingType').value = 'WholeCircle';
          document.getElementById('inputUnit').value = 'Metres';
          document.getElementById('angleInputMode').value = 'Absolute';
          document.getElementById('lengthType').value = 'chord';
          document.getElementById('closureTolerance').value = '10000';
          updateHeaders();
          document.getElementById('setSegmentsBtn').click();
        }
        // Generate initial report so Print works immediately
        setTimeout(autoRecalculate, 100);
      };

    })();
  </script>
</body>
</html>
