<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Area Calculator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: #eef2f3;
      color: #333;
    }
    .container {
      max-width: 1500px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    header {
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    h1 { margin: 0; font-size: 2.5em; color: #2c3e50; }
    .beta-note {
      margin: 10px 0 0;
      font-style: italic;
      color: #7f8c8d;
    }
    .controls, .segments, .diagram, .results {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px 20px;
      margin-bottom: 20px;
    }
    .controls label, .controls select, .controls input {
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .controls select,
    .controls input[type="number"],
    .controls input[type="text"],
    textarea {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
    }
    .controls button,
    .segments button,
    .results button {
      padding: 10px 15px;
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.3s ease;
    }
    .controls button:hover,
    .segments button:hover,
    .results button:hover {
      background: #2980b9;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: center;
      vertical-align: middle;
    }
    th { background: #f0f0f0; font-size: 0.85em; }
    canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    textarea {
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .error { border-color: #e74c3c !important; background-color: #fdf2f2 !important; }

    .field-group {
      display: flex;
      gap: 3px;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
    }
    .field-group input {
      width: 50px;
      padding: 5px 3px;
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }
    .field-group input.deg-field { width: 55px; }
    .field-group input.min-field,
    .field-group input.sec-field { width: 45px; }
    .field-group input.grads-field { width: 65px; }
    .field-group input.length-field { width: 70px; }
    .field-group input.radius-field { width: 60px; }
    .field-group select {
      padding: 5px 3px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }
    .field-group .field-label {
      font-size: 0.7em;
      color: #7f8c8d;
      margin-left: -1px;
    }
    .curve-select {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
      width: 45px;
    }

    .help-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      background: #3498db;
      color: #fff;
      border-radius: 50%;
      text-align: center;
      font-size: 11px;
      line-height: 16px;
      cursor: help;
      margin-left: 3px;
      font-weight: bold;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 260px;
      background-color: #2c3e50;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 50%;
      margin-left: -130px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.8em;
      line-height: 1.3;
    }
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .error-box {
      background: #fdf2f2;
      border: 1px solid #e74c3c;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #c0392b;
    }
    .error-box ul { margin: 5px 0 0 20px; padding: 0; }
    .warning-box {
      background: #fef9e7;
      border: 1px solid #f39c12;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #9a7b0a;
    }

    .starting-bearing-row {
      background: #e8f4f8;
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
      align-items: center;
      gap: 10px;
    }
    .starting-bearing-row.visible { display: flex; }
    .starting-bearing-row label { font-weight: 500; white-space: nowrap; }

    .print-report-header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 15px; margin-bottom: 20px; }
    .print-report-header h1 { font-size: 1.8em; color: #2c3e50; margin: 0 0 5px 0; }
    .print-report-header h2 { font-size: 1.1em; color: #7f8c8d; margin: 0; font-weight: 400; }
    .print-meta { text-align: right; font-size: 0.9em; color: #7f8c8d; margin-bottom: 15px; }
    .print-description { background: #f8f9fa; border-left: 4px solid #3498db; padding: 12px 15px; margin: 15px 0; font-style: italic; }
    .print-summary-box { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 15px; margin: 15px 0; }
    .print-summary-box h4 { margin: 0 0 12px 0; color: #2c3e50; font-size: 1.1em; }
    .print-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .print-summary-item { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dotted #ddd; }
    .print-summary-label { color: #7f8c8d; font-size: 0.9em; }
    .print-summary-value { font-weight: 600; color: #2c3e50; }
    .print-diagram-section { text-align: center; margin: 20px 0; }
    .print-diagram-section img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; }
    .print-diagram-caption { font-size: 0.85em; color: #7f8c8d; margin-top: 8px; font-style: italic; }
    .print-closed-status { background: #eafaf1; border: 1px solid #27ae60; border-radius: 4px; padding: 12px 15px; margin: 10px 0; color: #1e7e34; }
    .print-two-column { display: flex; gap: 30px; }
    .print-column { flex: 1; }
    .print-footer { margin-top: 25px; padding-top: 12px; border-top: 1px solid #ddd; font-size: 0.8em; color: #7f8c8d; }
    .print-footer-content { display: flex; justify-content: space-between; }

    @media print {
      @page { size: A4; margin: 15mm; }
      * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      body { margin: 0; padding: 0; background: #fff !important; font-size: 10pt; }
      .container { width: 100%; max-width: none; margin: 0; padding: 0; box-shadow: none; }
      header, .controls, .segments, .diagram, .beta-note { display: none !important; }
      .results { border: none; margin: 0; padding: 0; background: #fff; }
      .report textarea, .report button, .report h3:first-of-type { display: none !important; }
      #resultsDisplay table { width: 100%; border-collapse: collapse; margin: 10pt 0; font-size: 8pt; page-break-inside: avoid; }
      #resultsDisplay table th { background: #2c3e50 !important; color: #fff !important; padding: 6pt 4pt; }
      #resultsDisplay table td { padding: 5pt; border: 0.5pt solid #ddd; }
      .print-summary-box { background: #f8f9fa !important; page-break-inside: avoid; }
      .no-break { page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Area Calculator</h1>
      <p class="beta-note">Survey polygon area with curve support</p>
    </header>

    <div class="controls">
      <label for="inputUnit">Distance:</label>
      <select id="inputUnit">
        <option value="Metres" selected>Metres</option>
        <option value="DecimalFeet">Decimal Feet</option>
        <option value="FeetInches">Feet/Inches</option>
        <option value="Links">Links</option>
      </select>

      <label for="bearingType">Bearing:</label>
      <select id="bearingType">
        <option value="WholeCircle" selected>Whole Circle (D/M/S)</option>
        <option value="DecimalDegrees">Decimal Degrees</option>
        <option value="Quadrant">Quadrant</option>
        <option value="Internal">Internal Angles</option>
        <option value="Deflection">Deflection Angles</option>
        <option value="Grads">Grads</option>
      </select>

      <label for="angleInputMode">Mode:</label>
      <select id="angleInputMode">
        <option value="Absolute" selected>Absolute</option>
        <option value="Relative">Relative</option>
      </select>

      <br><br>
      <label for="numSegments"># Segments:</label>
      <input type="number" id="numSegments" value="4" min="3" max="100" style="width:60px;">
      <button id="setSegmentsBtn">Set</button>
      <button id="recalcBtn">Recalculate</button>

      <br><br>
      <label for="closureTolerance">Closure Tolerance:</label>
      <select id="closureTolerance">
        <option value="5000">1:5,000 (Cadastral)</option>
        <option value="10000" selected>1:10,000 (Standard)</option>
        <option value="15000">1:15,000 (High)</option>
        <option value="25000">1:25,000 (Very High)</option>
        <option value="0">No limit</option>
      </select>
      <label style="margin-left:15px;">
        <input type="checkbox" id="forceClose"> Force close polygon
        <span class="tooltip"><span class="help-icon">?</span>
          <span class="tooltip-text">When enabled, automatically closes the polygon by adjusting the final point to the start. Use only when misclosure is within acceptable tolerance.</span>
        </span>
      </label>

      <br><br>
      <button id="exportJsonBtn">Export JSON</button>
      <button id="importJsonBtn">Import JSON</button>
      <input type="file" id="importFileInput" accept=".json" style="display:none;">
      <button id="clearStorageBtn" style="background:#e67e22;">Clear Saved</button>
    </div>

    <div class="segments">
      <h3>Survey Segments</h3>

      <div id="startingBearingRow" class="starting-bearing-row">
        <label>Starting Bearing:</label>
        <div class="field-group">
          <input type="number" id="startBearingDeg" class="deg-field" value="0" placeholder="Deg">
          <span class="field-label">°</span>
          <input type="number" id="startBearingMin" class="min-field" value="0" min="0" max="59" placeholder="Min">
          <span class="field-label">'</span>
          <input type="number" id="startBearingSec" class="sec-field" value="0" min="0" max="59.999" step="0.1" placeholder="Sec">
          <span class="field-label">"</span>
        </div>
      </div>

      <div id="validationErrors"></div>

      <table id="segmentsTable">
        <thead>
          <tr>
            <th style="width:35px;">No.</th>
            <th id="bearingHeader">Bearing (D/M/S)</th>
            <th id="lengthHeader">Length (Chord)
              <select id="lengthType" style="font-size:0.75em;margin-left:5px;">
                <option value="chord" selected>Chord</option>
                <option value="arc">Arc</option>
              </select>
            </th>
            <th>Radius
              <span class="tooltip"><span class="help-icon">?</span>
                <span class="tooltip-text">Arc radius in metres. Leave blank for straight segments.</span>
              </span>
            </th>
            <th>Curve
              <span class="tooltip"><span class="help-icon">?</span>
                <span class="tooltip-text">L = arc bulges Left of chord direction<br>R = arc bulges Right of chord direction<br>Required if radius is set.</span>
              </span>
            </th>
            <th style="width:40px;">Flip</th>
            <th style="width:35px;">Del</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <br>
      <button id="addSegmentBtn">Add Segment</button>
    </div>

    <div class="diagram">
      <h3>Survey Diagram</h3>
      <canvas id="diagramCanvas" width="500" height="500"></canvas>
    </div>

    <div class="results">
      <div id="resultsDisplay">
        <p style="color: #7f8c8d; font-style: italic;">Enter at least 3 segments and click "Recalculate".</p>
      </div>
      <div class="report">
        <h3>Description</h3>
        <textarea id="planDescription" rows="2" placeholder="Plan description..."></textarea>
        <br>
        <button id="saveResultsBtn">Save</button>
        <button id="printPreviewBtn">Print</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ============================================
      // CONSTANTS
      // ============================================
      const TOLERANCE = 1e-6;
      const GRADS_TO_DEGREES = 0.9;
      const LINK_TO_METRES = 0.201168;
      const FEET_TO_METRES = 0.3048;
      const INCH_TO_METRES = 0.0254;

      let debounceTimer = null;
      function debounce(fn, delay = 150) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fn, delay);
      }

      // ============================================
      // DMS HELPERS
      // ============================================
      function dmsFieldsToDecimal(deg, min, sec, allowNegative = false) {
        const d = parseFloat(deg) || 0;
        const m = parseFloat(min) || 0;
        const s = parseFloat(sec) || 0;
        if (m < 0 || m >= 60) throw new Error(`Minutes must be 0-59`);
        if (s < 0 || s >= 60) throw new Error(`Seconds must be 0-59.999`);
        if (!allowNegative && d < 0) throw new Error(`Degrees cannot be negative`);
        const sign = d < 0 ? -1 : 1;
        return sign * (Math.abs(d) + m / 60 + s / 3600);
      }

      function decimalToDMSFields(decimal) {
        const sign = decimal < 0 ? -1 : 1;
        const abs = Math.abs(decimal);
        const deg = Math.floor(abs);
        const minFloat = (abs - deg) * 60;
        const min = Math.floor(minFloat);
        const sec = (minFloat - min) * 60;
        return { deg: sign * deg, min, sec: parseFloat(sec.toFixed(1)) };
      }

      function quadrantFieldsToDecimal(ns, deg, min, sec, ew) {
        const angle = dmsFieldsToDecimal(deg, min, sec, false);
        if (angle < 0 || angle > 90) throw new Error(`Quadrant angle must be 0-90°`);
        if (ns === 'N' && ew === 'E') return angle;
        if (ns === 'N' && ew === 'W') return 360 - angle;
        if (ns === 'S' && ew === 'E') return 180 - angle;
        if (ns === 'S' && ew === 'W') return 180 + angle;
        throw new Error('Invalid quadrant');
      }

      function decimalToQuadrantFields(bearing) {
        bearing = normalizeBearing(bearing);
        let ns, ew, angle;
        if (bearing <= 90) { ns = 'N'; ew = 'E'; angle = bearing; }
        else if (bearing <= 180) { ns = 'S'; ew = 'E'; angle = 180 - bearing; }
        else if (bearing <= 270) { ns = 'S'; ew = 'W'; angle = bearing - 180; }
        else { ns = 'N'; ew = 'W'; angle = 360 - bearing; }
        const dms = decimalToDMSFields(angle);
        return { ns, deg: dms.deg, min: dms.min, sec: dms.sec, ew };
      }

      function normalizeBearing(b) { return ((b % 360) + 360) % 360; }

      function decimalToDMS(b) {
        const dms = decimalToDMSFields(Math.abs(b));
        return `${b < 0 ? '-' : ''}${dms.deg}° ${dms.min}' ${dms.sec.toFixed(1)}"`;
      }

      function decimalToQuadrant(b) {
        const q = decimalToQuadrantFields(b);
        return `${q.ns}${q.deg}°${q.min}'${q.ew}`;
      }

      // ============================================
      // LENGTH HELPERS
      // ============================================
      function parseLengthFields(fields, unit) {
        if (unit === 'Metres') {
          const m = parseFloat(fields.m);
          if (isNaN(m) || m <= 0) throw new Error('Invalid length');
          return m;
        } else if (unit === 'DecimalFeet') {
          const ft = parseFloat(fields.ft);
          if (isNaN(ft) || ft <= 0) throw new Error('Invalid length');
          return ft * FEET_TO_METRES;
        } else if (unit === 'FeetInches') {
          const feet = parseFloat(fields.ft) || 0;
          const inches = parseFloat(fields.in) || 0;
          if (inches >= 12) throw new Error('Inches must be < 12');
          const total = feet * FEET_TO_METRES + inches * INCH_TO_METRES;
          if (total <= 0) throw new Error('Invalid length');
          return total;
        } else if (unit === 'Links') {
          const lk = parseFloat(fields.lk);
          if (isNaN(lk) || lk <= 0) throw new Error('Invalid length');
          return lk * LINK_TO_METRES;
        }
        throw new Error('Unknown unit');
      }

      function metresToLengthFields(m, unit) {
        if (unit === 'Metres') return { m: m.toFixed(3) };
        if (unit === 'DecimalFeet') return { ft: (m / FEET_TO_METRES).toFixed(3) };
        if (unit === 'FeetInches') {
          const ti = m / INCH_TO_METRES;
          return { ft: Math.floor(ti / 12).toString(), in: (ti % 12).toFixed(1) };
        }
        if (unit === 'Links') return { lk: (m / LINK_TO_METRES).toFixed(2) };
        return { m: m.toFixed(3) };
      }

      // ============================================
      // ARC GEOMETRY FUNCTIONS
      // ============================================

      /**
       * Central angle (radians) from chord and radius
       * theta = 2 * asin(c / (2R))
       */
      function arcCentralAngle(chord, radius) {
        const ratio = chord / (2 * radius);
        if (ratio > 1 + TOLERANCE) throw new Error('Chord exceeds diameter');
        return 2 * Math.asin(Math.min(ratio, 1));
      }

      /**
       * Arc length from chord and radius
       * s = R * theta
       */
      function arcLength(chord, radius) {
        const theta = arcCentralAngle(chord, radius);
        return radius * theta;
      }

      /**
       * Circular segment area (area between chord and arc)
       * Aseg = (R^2 / 2) * (theta - sin(theta))
       */
      function circularSegmentArea(chord, radius) {
        const theta = arcCentralAngle(chord, radius);
        return (radius * radius / 2) * (theta - Math.sin(theta));
      }

      /**
       * Convert arc length to chord length
       * Uses Newton-Raphson iteration: given s and R, find c where s = R * 2 * asin(c/(2R))
       */
      function arcLengthToChord(arcLen, radius) {
        if (arcLen <= 0 || radius <= 0) return 0;
        // theta = s / R
        const theta = arcLen / radius;
        if (theta >= Math.PI) throw new Error('Arc length exceeds semicircle');
        // chord = 2R * sin(theta/2)
        return 2 * radius * Math.sin(theta / 2);
      }

      function getLengthType() {
        return document.getElementById('lengthType').value;
      }

      // ============================================
      // GEOMETRY FUNCTIONS
      // ============================================

      function computeCoordinates(segments) {
        const points = [{ x: 0, y: 0 }];
        let x = 0, y = 0;
        for (const seg of segments) {
          const rad = seg.bearing * Math.PI / 180;
          x += seg.chord * Math.sin(rad);
          y += seg.chord * Math.cos(rad);
          points.push({ x, y });
        }
        return points;
      }

      /**
       * Signed shoelace area (positive = counterclockwise, negative = clockwise)
       */
      function computeSignedArea(points) {
        if (points.length < 3) return 0;
        let area = 0;
        const n = points.length;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          area += points[i].x * points[j].y;
          area -= points[j].x * points[i].y;
        }
        return area / 2;
      }

      /**
       * Compute total area accounting for arc segments
       */
      function computeAreaWithArcs(points, segments) {
        const signedChordArea = computeSignedArea(points);

        let arcAdjustment = 0;
        for (const seg of segments) {
          if (seg.radius > 0 && seg.curveDir) {
            const segArea = circularSegmentArea(seg.chord, seg.radius);
            // R = bulge right = add area, L = bulge left = subtract area
            // But this depends on traverse direction. For clockwise traverse:
            // R adds, L subtracts. We'll use sign of chord area to determine.
            if (seg.curveDir === 'R') {
              arcAdjustment += segArea;
            } else if (seg.curveDir === 'L') {
              arcAdjustment -= segArea;
            }
          }
        }

        // If traverse is clockwise (negative signed area), flip adjustment
        if (signedChordArea < 0) {
          arcAdjustment = -arcAdjustment;
        }

        return Math.abs(signedChordArea + arcAdjustment);
      }

      /**
       * Compute perimeter using arc lengths where applicable
       */
      function computePerimeterWithArcs(segments) {
        let total = 0;
        for (const seg of segments) {
          if (seg.radius > 0 && seg.curveDir) {
            total += arcLength(seg.chord, seg.radius);
          } else {
            total += seg.chord;
          }
        }
        return total;
      }

      function computeMisclosure(points) {
        if (points.length < 2) return null;
        const first = points[0], last = points[points.length - 1];
        const dx = first.x - last.x, dy = first.y - last.y;
        const len = Math.hypot(dx, dy);
        if (len < TOLERANCE) return null;
        return { length_m: len, bearing: normalizeBearing(Math.atan2(dx, dy) * 180 / Math.PI) };
      }

      function convertAreaValues(m2) {
        return {
          m2: m2.toFixed(2) + ' m²',
          ft2: (m2 * 10.7639).toFixed(2) + ' ft²',
          ha: (m2 / 10000).toFixed(4) + ' ha',
          acres: (m2 * 0.000247105).toFixed(4) + ' acres'
        };
      }

      function convertPerimeterValues(m) {
        return {
          m: m.toFixed(2) + ' m',
          ft: (m * 3.28084).toFixed(2) + ' ft',
          links: (m / LINK_TO_METRES).toFixed(2) + ' links'
        };
      }

      // ============================================
      // DIAGRAM DRAWING WITH ARCS
      // ============================================

      function drawDiagram(points, segments, misclosure, options = {}) {
        const { allowFill = true } = options;
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (points.length < 2) {
          ctx.fillStyle = '#7f8c8d';
          ctx.font = '14px Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough points', canvas.width / 2, canvas.height / 2);
          return;
        }

        const xs = points.map(p => p.x), ys = points.map(p => p.y);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);

        const padding = 50;
        const rangeX = maxX - minX || 1, rangeY = maxY - minY || 1;
        const scale = Math.min((canvas.width - 2 * padding) / rangeX, (canvas.height - 2 * padding) / rangeY);
        const offsetX = (canvas.width - rangeX * scale) / 2 - minX * scale;
        const offsetY = (canvas.height - rangeY * scale) / 2 + maxY * scale;

        const toCanvas = p => ({ x: p.x * scale + offsetX, y: -p.y * scale + offsetY });
        const cPoints = points.map(toCanvas);

        // Fill polygon (using chord polygon for simplicity)
        if (allowFill && points.length >= 3 && !misclosure) {
          ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
          ctx.beginPath();
          ctx.moveTo(cPoints[0].x, cPoints[0].y);
          for (let i = 1; i < cPoints.length; i++) ctx.lineTo(cPoints[i].x, cPoints[i].y);
          ctx.closePath();
          ctx.fill();
        }

        // Draw segments (lines or arcs)
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;

        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          const p0 = cPoints[i], p1 = cPoints[i + 1];

          if (seg.radius > 0 && seg.curveDir && p1) {
            // Draw arc
            drawArcSegment(ctx, p0, p1, seg.radius * scale, seg.curveDir);
          } else if (p1) {
            // Draw straight line
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
          }
        }

        // Draw misclosure line if not closed
        if (misclosure && cPoints.length > 1) {
          ctx.strokeStyle = '#e74c3c';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cPoints[cPoints.length - 1].x, cPoints[cPoints.length - 1].y);
          ctx.lineTo(cPoints[0].x, cPoints[0].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Vertices
        ctx.fillStyle = '#2c3e50';
        for (const cp of cPoints) {
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Segment labels
        ctx.fillStyle = '#2980b9';
        ctx.font = 'bold 12px Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let i = 0; i < cPoints.length - 1; i++) {
          const p0 = cPoints[i], p1 = cPoints[i + 1];
          const midX = (p0.x + p1.x) / 2, midY = (p0.y + p1.y) / 2;
          const dx = p1.x - p0.x, dy = p1.y - p0.y;
          const len = Math.hypot(dx, dy) || 1;
          ctx.fillText((i + 1).toString(), midX - dy / len * 15, midY + dx / len * 15);
        }

        // North arrow
        ctx.save();
        ctx.translate(canvas.width - 25, 25);
        ctx.strokeStyle = '#2c3e50';
        ctx.fillStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 15);
        ctx.lineTo(0, -10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-4, -2);
        ctx.lineTo(4, -2);
        ctx.closePath();
        ctx.fill();
        ctx.font = 'bold 10px Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('N', 0, -16);
        ctx.restore();
      }

      /**
       * Draw an arc segment between two canvas points
       */
      function drawArcSegment(ctx, p0, p1, scaledRadius, curveDir) {
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        const chordLen = Math.hypot(dx, dy);

        if (chordLen < TOLERANCE || scaledRadius < chordLen / 2 - TOLERANCE) {
          // Fallback to line if geometry invalid
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
          return;
        }

        // Midpoint
        const mx = (p0.x + p1.x) / 2, my = (p0.y + p1.y) / 2;

        // Distance from midpoint to center
        const halfChord = chordLen / 2;
        const h = Math.sqrt(Math.max(0, scaledRadius * scaledRadius - halfChord * halfChord));

        // Unit normal to chord (perpendicular)
        const nx = -dy / chordLen, ny = dx / chordLen;

        // Choose center based on curve direction
        // In canvas coords: +Y is down. L/R relative to travel direction.
        // If curveDir = R, center is to the right of chord direction
        // If curveDir = L, center is to the left
        let cx, cy;
        if (curveDir === 'R') {
          cx = mx + h * nx;
          cy = my + h * ny;
        } else {
          cx = mx - h * nx;
          cy = my - h * ny;
        }

        // Compute angles from center to p0 and p1
        const startAngle = Math.atan2(p0.y - cy, p0.x - cx);
        const endAngle = Math.atan2(p1.y - cy, p1.x - cx);

        // Determine if we should draw counterclockwise
        // For R curves: draw counterclockwise (canvas coords)
        // For L curves: draw clockwise
        const anticlockwise = (curveDir === 'R');

        ctx.beginPath();
        ctx.arc(cx, cy, scaledRadius, startAngle, endAngle, anticlockwise);
        ctx.stroke();
      }

      // ============================================
      // UI: Segment Table
      // ============================================

      const segmentsTableBody = document.querySelector('#segmentsTable tbody');

      // ============================================
      // DATA PERSISTENCE
      // ============================================

      const STORAGE_KEY = 'areaCalc_savedData';

      function collectAllData() {
        const rows = Array.from(segmentsTableBody.querySelectorAll('tr'));
        const segments = rows.map(row => ({
          bearing: getBearingFromRow(row),
          length: getLengthFromRow(row),
          radius: getRadiusFromRow(row),
          curve: getCurveFromRow(row)
        }));

        return {
          version: 2,
          settings: {
            bearingType: getBearingType(),
            inputUnit: getInputUnit(),
            angleInputMode: getAngleInputMode(),
            lengthType: getLengthType(),
            closureTolerance: document.getElementById('closureTolerance').value,
            forceClose: document.getElementById('forceClose').checked
          },
          startingBearing: {
            deg: document.getElementById('startBearingDeg').value,
            min: document.getElementById('startBearingMin').value,
            sec: document.getElementById('startBearingSec').value
          },
          segments,
          description: document.getElementById('planDescription').value
        };
      }

      function saveToLocalStorage() {
        try {
          const data = collectAllData();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
      }

      function loadFromLocalStorage() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (!saved) return false;
          const data = JSON.parse(saved);
          return restoreData(data);
        } catch (e) {
          console.warn('Could not load from localStorage:', e);
          return false;
        }
      }

      function restoreData(data) {
        if (!data || !data.segments || !Array.isArray(data.segments) || data.segments.length === 0) {
          localStorage.removeItem(STORAGE_KEY);
          return false;
        }

        try {
          // Restore settings
          if (data.settings) {
            document.getElementById('bearingType').value = data.settings.bearingType || 'WholeCircle';
            document.getElementById('inputUnit').value = data.settings.inputUnit || 'Metres';
            document.getElementById('angleInputMode').value = data.settings.angleInputMode || 'Absolute';
            document.getElementById('lengthType').value = data.settings.lengthType || 'chord';
            document.getElementById('closureTolerance').value = data.settings.closureTolerance || '10000';
            document.getElementById('forceClose').checked = data.settings.forceClose || false;
          }

          // Restore starting bearing
          if (data.startingBearing) {
            document.getElementById('startBearingDeg').value = data.startingBearing.deg || 0;
            document.getElementById('startBearingMin').value = data.startingBearing.min || 0;
            document.getElementById('startBearingSec').value = data.startingBearing.sec || 0;
          }

          // Restore description
          if (data.description) {
            document.getElementById('planDescription').value = data.description;
          }

          // Restore segments
          updateHeaders();
          clearSegmentsTable();
          for (const seg of data.segments) {
            addSegmentRow(seg.bearing, seg.length, seg.radius || '', seg.curve || '');
          }

          liveUpdateDiagram();
          return true;
        } catch (e) {
          console.error('Error restoring data:', e);
          localStorage.removeItem(STORAGE_KEY);
          return false;
        }
      }

      function exportToJson() {
        const data = collectAllData();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const desc = document.getElementById('planDescription').value.trim();
        const filename = desc ? desc.replace(/[^a-z0-9]/gi, '_').substring(0, 30) : 'survey_data';
        a.download = `${filename}.json`;
        a.click();
      }

      function importFromJson(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (restoreData(data)) {
              saveToLocalStorage();
              alert('Data imported successfully!');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Error reading file: ' + err.message);
          }
        };
        reader.readAsText(file);
      }

      function clearSegmentsTable() { segmentsTableBody.innerHTML = ''; }

      function getBearingType() { return document.getElementById('bearingType').value; }
      function getInputUnit() { return document.getElementById('inputUnit').value; }
      function getAngleInputMode() { return document.getElementById('angleInputMode').value; }

      function createBearingInputs(bearingType, defaults = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.bearingType = bearingType;

        if (bearingType === 'Grads') {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'grads-field';
          input.placeholder = 'Grads';
          input.step = 'any';
          input.value = defaults?.grads ?? '';
          input.addEventListener('input', triggerLiveUpdate);
          container.appendChild(input);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: 'g' }));
        } else if (bearingType === 'Quadrant') {
          const nsSelect = document.createElement('select');
          nsSelect.innerHTML = '<option value="N">N</option><option value="S">S</option>';
          nsSelect.value = defaults?.ns ?? 'N';
          nsSelect.addEventListener('change', triggerLiveUpdate);
          container.appendChild(nsSelect);

          ['deg', 'min', 'sec'].forEach((f, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = f + '-field';
            input.min = 0;
            input.max = f === 'deg' ? 90 : 59;
            input.step = f === 'sec' ? '0.1' : '1';
            input.value = defaults?.[f] ?? '0';
            input.addEventListener('input', triggerLiveUpdate);
            container.appendChild(input);
            container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: ['°', "'", '"'][i] }));
          });

          const ewSelect = document.createElement('select');
          ewSelect.innerHTML = '<option value="E">E</option><option value="W">W</option>';
          ewSelect.value = defaults?.ew ?? 'E';
          ewSelect.addEventListener('change', triggerLiveUpdate);
          container.appendChild(ewSelect);
        } else {
          const allowNeg = bearingType === 'Deflection';
          ['deg', 'min', 'sec'].forEach((f, i) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = f + '-field';
            if (f !== 'deg' || !allowNeg) input.min = 0;
            if (f !== 'deg') input.max = 59;
            input.step = f === 'sec' ? '0.1' : '1';
            input.value = defaults?.[f] ?? '0';
            input.addEventListener('input', triggerLiveUpdate);
            container.appendChild(input);
            container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: ['°', "'", '"'][i] }));
          });
        }
        return container;
      }

      function createLengthInputs(unit, defaults = null) {
        const container = document.createElement('div');
        container.className = 'field-group';
        container.dataset.inputUnit = unit;

        if (unit === 'FeetInches') {
          const ftInput = document.createElement('input');
          ftInput.type = 'number';
          ftInput.className = 'length-field';
          ftInput.placeholder = 'Ft';
          ftInput.min = 0;
          ftInput.value = defaults?.ft ?? '';
          ftInput.addEventListener('input', triggerLiveUpdate);
          container.appendChild(ftInput);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: "'" }));

          const inInput = document.createElement('input');
          inInput.type = 'number';
          inInput.className = 'length-field';
          inInput.placeholder = 'In';
          inInput.min = 0;
          inInput.max = 11.999;
          inInput.step = '0.1';
          inInput.value = defaults?.in ?? '';
          inInput.addEventListener('input', triggerLiveUpdate);
          container.appendChild(inInput);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: '"' }));
        } else {
          const input = document.createElement('input');
          input.type = 'number';
          input.className = 'length-field';
          input.step = 'any';
          input.min = 0;
          const units = { Metres: 'm', DecimalFeet: 'ft', Links: 'lk' };
          input.placeholder = units[unit] || 'm';
          const key = unit === 'Metres' ? 'm' : unit === 'DecimalFeet' ? 'ft' : 'lk';
          input.value = defaults?.[key] ?? '';
          input.addEventListener('input', triggerLiveUpdate);
          container.appendChild(input);
          container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: units[unit] || 'm' }));
        }
        return container;
      }

      function createRadiusInput(val = '') {
        const container = document.createElement('div');
        container.className = 'field-group';
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'radius-field';
        input.placeholder = '-';
        input.step = 'any';
        input.min = 0;
        input.value = val;
        input.addEventListener('input', triggerLiveUpdate);
        container.appendChild(input);
        container.appendChild(Object.assign(document.createElement('span'), { className: 'field-label', textContent: 'm' }));
        return container;
      }

      function createCurveSelect(val = '') {
        const select = document.createElement('select');
        select.className = 'curve-select';
        select.innerHTML = '<option value="">-</option><option value="L">L</option><option value="R">R</option>';
        select.value = val;
        select.addEventListener('change', triggerLiveUpdate);
        return select;
      }

      function getDefaultBearing(idx) {
        const bt = getBearingType(), mode = getAngleInputMode();
        if (bt === 'Internal') return { deg: 90, min: 0, sec: 0 };
        if (bt === 'Deflection') return { deg: idx === 0 ? 0 : 90, min: 0, sec: 0 };
        if (bt === 'Quadrant') {
          const b = [{ ns: 'N', deg: 0, ew: 'E' }, { ns: 'N', deg: 90, ew: 'E' }, { ns: 'S', deg: 0, ew: 'E' }, { ns: 'N', deg: 90, ew: 'W' }];
          return { ...b[idx % 4], min: 0, sec: 0 };
        }
        if (bt === 'Grads') return { grads: [0, 100, 200, 300][idx % 4] };
        if (mode === 'Relative') return { deg: idx === 0 ? 0 : 90, min: 0, sec: 0 };
        return { deg: [0, 90, 180, 270][idx % 4], min: 0, sec: 0 };
      }

      function getDefaultLength() {
        const u = getInputUnit();
        if (u === 'Metres') return { m: '10' };
        if (u === 'DecimalFeet') return { ft: '32.81' };
        if (u === 'FeetInches') return { ft: '32', in: '10' };
        if (u === 'Links') return { lk: '49.71' };
        return { m: '10' };
      }

      function addSegmentRow(bearingVals = null, lengthVals = null, radiusVal = '', curveVal = '') {
        const idx = segmentsTableBody.querySelectorAll('tr').length;
        const bt = getBearingType(), unit = getInputUnit();
        const row = document.createElement('tr');

        // Col 0: Number
        row.appendChild(Object.assign(document.createElement('td'), { textContent: (idx + 1).toString() }));

        // Col 1: Bearing
        const cellBearing = document.createElement('td');
        cellBearing.appendChild(createBearingInputs(bt, bearingVals ?? getDefaultBearing(idx)));
        row.appendChild(cellBearing);

        // Col 2: Length
        const cellLength = document.createElement('td');
        cellLength.appendChild(createLengthInputs(unit, lengthVals ?? getDefaultLength()));
        row.appendChild(cellLength);

        // Col 3: Radius
        const cellRadius = document.createElement('td');
        cellRadius.appendChild(createRadiusInput(radiusVal));
        row.appendChild(cellRadius);

        // Col 4: Curve direction
        const cellCurve = document.createElement('td');
        cellCurve.appendChild(createCurveSelect(curveVal));
        row.appendChild(cellCurve);

        // Col 5: Flip
        const cellFlip = document.createElement('td');
        const flipBtn = document.createElement('button');
        flipBtn.textContent = '↔';
        flipBtn.title = 'Flip 180°';
        flipBtn.style.padding = '4px 8px';
        flipBtn.addEventListener('click', () => flipSegment(row));
        cellFlip.appendChild(flipBtn);
        row.appendChild(cellFlip);

        // Col 6: Delete
        const cellDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = '✕';
        delBtn.style.padding = '4px 8px';
        delBtn.style.background = '#e74c3c';
        delBtn.addEventListener('click', () => { row.remove(); updateSegmentNumbers(); triggerLiveUpdate(); });
        cellDel.appendChild(delBtn);
        row.appendChild(cellDel);

        segmentsTableBody.appendChild(row);
        updateSegmentNumbers();
      }

      function updateSegmentNumbers() {
        segmentsTableBody.querySelectorAll('tr').forEach((row, i) => {
          row.children[0].textContent = (i + 1).toString();
        });
      }

      // Row accessors (column indices: 0=No, 1=Bearing, 2=Length, 3=Radius, 4=Curve, 5=Flip, 6=Del)
      function getBearingFromRow(row) {
        const container = row.children[1].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') return { grads: parseFloat(inputs[0].value) || 0 };
        if (bt === 'Quadrant') return { ns: selects[0].value, deg: parseFloat(inputs[0].value) || 0, min: parseFloat(inputs[1].value) || 0, sec: parseFloat(inputs[2].value) || 0, ew: selects[1].value };
        return { deg: parseFloat(inputs[0].value) || 0, min: parseFloat(inputs[1].value) || 0, sec: parseFloat(inputs[2].value) || 0 };
      }

      function setBearingInRow(row, vals) {
        const container = row.children[1].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') { inputs[0].value = vals.grads ?? 0; }
        else if (bt === 'Quadrant') { selects[0].value = vals.ns ?? 'N'; inputs[0].value = vals.deg ?? 0; inputs[1].value = vals.min ?? 0; inputs[2].value = vals.sec ?? 0; selects[1].value = vals.ew ?? 'E'; }
        else { inputs[0].value = vals.deg ?? 0; inputs[1].value = vals.min ?? 0; inputs[2].value = vals.sec ?? 0; }
      }

      function getLengthFromRow(row) {
        const container = row.children[2].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        if (u === 'FeetInches') return { ft: inputs[0].value, in: inputs[1].value };
        const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
        return { [key]: inputs[0].value };
      }

      function getRadiusFromRow(row) {
        return row.children[3].querySelector('input').value;
      }

      function getCurveFromRow(row) {
        return row.children[4].querySelector('select').value;
      }

      // ============================================
      // PARSING
      // ============================================

      function parseBearingFromRow(row) {
        const container = row.children[1].querySelector('.field-group');
        const bt = container.dataset.bearingType;
        const inputs = container.querySelectorAll('input');
        const selects = container.querySelectorAll('select');
        if (bt === 'Grads') {
          const g = parseFloat(inputs[0].value);
          if (isNaN(g)) throw new Error('Invalid grads');
          return g * GRADS_TO_DEGREES;
        }
        if (bt === 'Quadrant') return quadrantFieldsToDecimal(selects[0].value, inputs[0].value, inputs[1].value, inputs[2].value, selects[1].value);
        return dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, bt === 'Deflection');
      }

      function parseLengthFromRow(row, radius = 0) {
        const container = row.children[2].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        let lengthM;
        if (u === 'FeetInches') {
          lengthM = parseLengthFields({ ft: inputs[0].value, in: inputs[1].value }, 'FeetInches');
        } else {
          const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
          lengthM = parseLengthFields({ [key]: inputs[0].value }, u);
        }

        // If arc length mode and radius is set, convert arc to chord
        const lengthType = getLengthType();
        if (lengthType === 'arc' && radius > 0) {
          return arcLengthToChord(lengthM, radius);
        }
        return lengthM;
      }

      function getRawLengthFromRow(row) {
        // Get raw length value without arc-to-chord conversion (for audit trail)
        const container = row.children[2].querySelector('.field-group');
        const inputs = container.querySelectorAll('input');
        const u = container.dataset.inputUnit;
        if (u === 'FeetInches') {
          return parseLengthFields({ ft: inputs[0].value, in: inputs[1].value }, 'FeetInches');
        }
        const key = u === 'Metres' ? 'm' : u === 'DecimalFeet' ? 'ft' : 'lk';
        return parseLengthFields({ [key]: inputs[0].value }, u);
      }

      function parseStartingBearing() {
        return dmsFieldsToDecimal(
          document.getElementById('startBearingDeg').value,
          document.getElementById('startBearingMin').value,
          document.getElementById('startBearingSec').value, false
        );
      }

      // ============================================
      // LIVE UPDATE
      // ============================================

      function parseSegmentsPermissive() {
        const bt = getBearingType(), mode = getAngleInputMode();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const segments = [];
        let currentBearing = 0;

        if (bt === 'Internal' || bt === 'Deflection') {
          try { currentBearing = normalizeBearing(parseStartingBearing()); }
          catch { return segments; }
        }

        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          let bearing, chord, radius, curveDir;

          try {
            const raw = parseBearingFromRow(row);
            if (bt === 'Internal') {
              bearing = i === 0 ? currentBearing : normalizeBearing(currentBearing + 180 - raw);
              if (i > 0) currentBearing = bearing;
            } else if (bt === 'Deflection') {
              bearing = normalizeBearing(currentBearing + raw);
              currentBearing = bearing;
            } else if (mode === 'Relative') {
              currentBearing = i === 0 ? normalizeBearing(raw) : normalizeBearing(currentBearing + raw);
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(raw);
            }
          } catch { break; }

          radius = parseFloat(getRadiusFromRow(row)) || 0;
          curveDir = getCurveFromRow(row);

          try { chord = parseLengthFromRow(row, radius); } catch { break; }

          // Basic validation for live preview
          if (radius > 0 && chord > 2 * radius + TOLERANCE) break;

          segments.push({ bearing, chord, radius, curveDir });
        }
        return segments;
      }

      function liveUpdateDiagram() {
        const segments = parseSegmentsPermissive();
        const points = computeCoordinates(segments);
        const canClose = segments.length >= 3;
        const misclosure = canClose ? computeMisclosure(points) : { length_m: 1 };
        const allowFill = canClose && !misclosure;
        drawDiagram(points, segments, canClose ? misclosure : null, { allowFill });
      }

      function triggerLiveUpdate() {
        debounce(() => {
          liveUpdateDiagram();
          saveToLocalStorage();
        }, 150);
      }

      // ============================================
      // FLIP
      // ============================================

      function flipSegment(row) {
        const container = row.children[1].querySelector('.field-group');
        const bt = container.dataset.bearingType;

        if (bt === 'Internal') {
          alert('Flip not supported for Internal angles');
          return;
        }

        try {
          if (bt === 'Deflection') {
            const vals = getBearingFromRow(row);
            const dec = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, true);
            setBearingInRow(row, decimalToDMSFields(-dec));
          } else if (bt === 'Grads') {
            const vals = getBearingFromRow(row);
            setBearingInRow(row, { grads: ((vals.grads + 200) % 400).toFixed(2) });
          } else if (bt === 'Quadrant') {
            const vals = getBearingFromRow(row);
            const dec = quadrantFieldsToDecimal(vals.ns, vals.deg, vals.min, vals.sec, vals.ew);
            setBearingInRow(row, decimalToQuadrantFields(normalizeBearing(dec + 180)));
          } else {
            const vals = getBearingFromRow(row);
            const dec = dmsFieldsToDecimal(vals.deg, vals.min, vals.sec, false);
            setBearingInRow(row, decimalToDMSFields(normalizeBearing(dec + 180)));
          }
          triggerLiveUpdate();
        } catch (e) { console.error('Flip error:', e); }
      }

      // ============================================
      // REBUILD ROWS
      // ============================================

      function rebuildAllRows() {
        const bt = getBearingType(), unit = getInputUnit();
        const rows = Array.from(segmentsTableBody.querySelectorAll('tr'));

        const saved = rows.map(row => {
          let bearingDeg = null, lengthM = null;
          try {
            const oldCont = row.children[1].querySelector('.field-group');
            const oldBt = oldCont.dataset.bearingType;
            const inputs = oldCont.querySelectorAll('input');
            const selects = oldCont.querySelectorAll('select');
            if (oldBt === 'Grads') bearingDeg = (parseFloat(inputs[0].value) || 0) * GRADS_TO_DEGREES;
            else if (oldBt === 'Quadrant') bearingDeg = quadrantFieldsToDecimal(selects[0].value, inputs[0].value, inputs[1].value, inputs[2].value, selects[1].value);
            else bearingDeg = dmsFieldsToDecimal(inputs[0].value, inputs[1].value, inputs[2].value, oldBt === 'Deflection');
          } catch { bearingDeg = null; }
          try { lengthM = parseLengthFromRow(row); } catch { lengthM = null; }
          return { bearingDeg, lengthM, radius: getRadiusFromRow(row), curve: getCurveFromRow(row) };
        });

        clearSegmentsTable();

        saved.forEach((d, i) => {
          let bv = null;
          if (d.bearingDeg !== null) {
            if (bt === 'Grads') bv = { grads: (d.bearingDeg / GRADS_TO_DEGREES).toFixed(2) };
            else if (bt === 'Quadrant') bv = decimalToQuadrantFields(d.bearingDeg);
            else bv = decimalToDMSFields(d.bearingDeg);
          }
          let lv = null;
          if (d.lengthM !== null) lv = metresToLengthFields(d.lengthM, unit);
          addSegmentRow(bv, lv, d.radius, d.curve);
        });

        updateHeaders();
        liveUpdateDiagram();
      }

      function updateHeaders() {
        const bt = getBearingType(), unit = getInputUnit();
        const bh = document.getElementById('bearingHeader');
        bh.textContent = bt === 'Grads' ? 'Bearing (Grads)' : bt === 'Quadrant' ? 'Bearing (Quadrant)' : bt === 'Internal' ? 'Internal Angle' : bt === 'Deflection' ? 'Deflection' : 'Bearing (D/M/S)';

        const lh = document.getElementById('lengthHeader');
        lh.textContent = unit === 'DecimalFeet' ? 'Length/Chord (ft)' : unit === 'FeetInches' ? 'Length/Chord (ft/in)' : unit === 'Links' ? 'Length/Chord (lk)' : 'Length/Chord (m)';

        const sr = document.getElementById('startingBearingRow');
        sr.classList.toggle('visible', bt === 'Internal' || bt === 'Deflection');
      }

      // ============================================
      // VALIDATION & RECALCULATE
      // ============================================

      function validateAndParseInputs() {
        const bt = getBearingType(), mode = getAngleInputMode();
        const unit = getInputUnit();
        const lengthType = getLengthType();
        const rows = segmentsTableBody.querySelectorAll('tr');
        const errors = [], segments = [], rawInputs = [];
        let currentBearing = 0;

        // Clear errors
        rows.forEach(row => {
          row.children[1].querySelectorAll('input').forEach(i => i.classList.remove('error'));
          row.children[2].querySelectorAll('input').forEach(i => i.classList.remove('error'));
          row.children[3].querySelector('input').classList.remove('error');
          row.children[4].querySelector('select').classList.remove('error');
        });

        if (rows.length < 3) errors.push('At least 3 segments required.');

        // Check for curves in relative/internal/deflection modes
        let hasCurves = false;
        rows.forEach(row => {
          const r = parseFloat(getRadiusFromRow(row)) || 0;
          if (r > 0) hasCurves = true;
        });

        if (hasCurves && (bt === 'Internal' || bt === 'Deflection' || mode === 'Relative')) {
          errors.push('Curves require Absolute bearing mode (not Internal/Deflection/Relative). Break curves into chord segments or switch to Absolute mode.');
        }

        if (bt === 'Internal' || bt === 'Deflection') {
          try { currentBearing = normalizeBearing(parseStartingBearing()); }
          catch (e) {
            document.getElementById('startBearingDeg').classList.add('error');
            errors.push(`Starting bearing: ${e.message}`);
          }
        }

        rows.forEach((row, i) => {
          let bearing, chord, radius, curveDir, rawBearing, rawLength;
          let valid = true;

          // Capture raw bearing input for audit trail
          rawBearing = getBearingFromRow(row);

          try {
            const raw = parseBearingFromRow(row);
            if (bt === 'Internal') {
              bearing = i === 0 ? currentBearing : normalizeBearing(currentBearing + 180 - raw);
              if (i > 0) currentBearing = bearing;
            } else if (bt === 'Deflection') {
              bearing = normalizeBearing(currentBearing + raw);
              currentBearing = bearing;
            } else if (mode === 'Relative') {
              currentBearing = i === 0 ? normalizeBearing(raw) : normalizeBearing(currentBearing + raw);
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(raw);
            }
          } catch (e) {
            row.children[1].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
            errors.push(`Seg ${i + 1} bearing: ${e.message}`);
            valid = false;
          }

          radius = parseFloat(getRadiusFromRow(row)) || 0;
          curveDir = getCurveFromRow(row);

          // Capture raw length for audit trail
          try { rawLength = getRawLengthFromRow(row); } catch { rawLength = 0; }

          try { chord = parseLengthFromRow(row, radius); }
          catch (e) {
            row.children[2].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
            errors.push(`Seg ${i + 1} length: ${e.message}`);
            valid = false;
          }

          // Curve validation
          if (radius > 0) {
            if (!curveDir) {
              row.children[4].querySelector('select').classList.add('error');
              errors.push(`Seg ${i + 1}: Radius set but Curve direction (L/R) missing.`);
              valid = false;
            }
            if (valid && chord > 2 * radius + TOLERANCE) {
              row.children[2].querySelectorAll('input').forEach(inp => inp.classList.add('error'));
              row.children[3].querySelector('input').classList.add('error');
              const lenLabel = lengthType === 'arc' ? 'Arc' : 'Chord';
              errors.push(`Seg ${i + 1}: ${lenLabel} too long for radius (chord ${chord.toFixed(2)}m > diameter ${(2 * radius).toFixed(2)}m).`);
              valid = false;
            }
          } else if (curveDir) {
            // Curve direction set but no radius - just ignore curveDir
            curveDir = '';
          }

          if (valid) {
            segments.push({ bearing, chord, radius, curveDir });
            rawInputs.push({
              bearingType: bt,
              bearingInput: rawBearing,
              lengthType,
              lengthInput: rawLength,
              lengthUnit: unit,
              radius,
              curveDir
            });
          }
        });

        return { valid: errors.length === 0 && segments.length === rows.length, segments, rawInputs, errors };
      }

      function recalculate() {
        const errDiv = document.getElementById('validationErrors');
        const resDiv = document.getElementById('resultsDisplay');
        const result = validateAndParseInputs();

        if (result.errors.length > 0) {
          errDiv.innerHTML = `<div class="error-box"><strong>Fix errors:</strong><ul>${result.errors.map(e => `<li>${e}</li>`).join('')}</ul></div>`;
          resDiv.innerHTML = '<p style="color:#e74c3c;">Cannot calculate.</p>';
          return;
        }

        errDiv.innerHTML = '';

        const segments = result.segments;
        const rawInputs = result.rawInputs;
        let points = computeCoordinates(segments);
        const perimeter = computePerimeterWithArcs(segments);
        let misclosure = computeMisclosure(points);

        // Tolerance check
        const toleranceLimit = parseInt(document.getElementById('closureTolerance').value);
        const forceClose = document.getElementById('forceClose').checked;
        let toleranceWarning = null;
        let forceClosed = false;

        if (misclosure && toleranceLimit > 0) {
          const actualRatio = perimeter / misclosure.length_m;
          if (actualRatio < toleranceLimit) {
            toleranceWarning = {
              expected: `1:${toleranceLimit.toLocaleString()}`,
              actual: `1:${Math.round(actualRatio).toLocaleString()}`,
              misclosure: misclosure.length_m
            };
          }
        }

        // Force close if enabled and within reasonable tolerance
        if (forceClose && misclosure) {
          // Only force close if misclosure is less than 1% of perimeter
          if (misclosure.length_m < perimeter * 0.01) {
            // Adjust final point to close the polygon
            points[points.length - 1] = { x: points[0].x, y: points[0].y };
            misclosure = null;
            forceClosed = true;
          }
        }

        const area = computeAreaWithArcs(points, segments);

        drawDiagram(points, segments, misclosure);
        resDiv.innerHTML = generateReport(area, perimeter, misclosure, segments, rawInputs, toleranceWarning, forceClosed);
        saveToLocalStorage();
      }

      // ============================================
      // REPORT
      // ============================================

      function formatRawBearing(raw, bearingType) {
        if (bearingType === 'Grads') return `${raw.grads}g`;
        if (bearingType === 'Quadrant') return `${raw.ns}${raw.deg}°${raw.min}'${raw.sec}"${raw.ew}`;
        return `${raw.deg}°${raw.min}'${raw.sec}"`;
      }

      function generateReport(area, perimeter, misclosure, segments, rawInputs = [], toleranceWarning = null, forceClosed = false) {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
        const unit = getInputUnit();
        const lengthType = getLengthType();
        const planDesc = document.getElementById('planDescription').value.trim();

        const areaVals = convertAreaValues(area);
        const perimVals = convertPerimeterValues(perimeter);

        let closureHtml, closureStatus, accuracyRatio = 'N/A';
        if (misclosure) {
          accuracyRatio = perimeter > 0 ? `1:${Math.round(perimeter / misclosure.length_m).toLocaleString()}` : 'N/A';
          closureStatus = 'Open';
          closureHtml = `<div class="warning-box no-break"><strong>⚠ Polygon Does Not Close</strong><br>Misclosure: ${misclosure.length_m.toFixed(4)} m at ${misclosure.bearing.toFixed(2)}°<br>Accuracy: ${accuracyRatio}</div>`;
        } else {
          closureStatus = forceClosed ? 'Force Closed' : 'Closed';
          closureHtml = forceClosed
            ? `<div class="print-closed-status no-break" style="background:#fef9e7;border-color:#f39c12;color:#9a7b0a;"><strong>⚠ Polygon Force Closed</strong><br>Final point adjusted to close the traverse.</div>`
            : `<div class="print-closed-status no-break"><strong>✓ Polygon is Closed</strong></div>`;
        }

        // Tolerance warning
        let toleranceHtml = '';
        if (toleranceWarning) {
          toleranceHtml = `<div class="error-box no-break"><strong>⚠ Tolerance Exceeded</strong><br>
            Expected: ${toleranceWarning.expected}<br>
            Actual: ${toleranceWarning.actual}<br>
            Misclosure: ${toleranceWarning.misclosure.toFixed(4)} m<br>
            <em>This traverse does not meet the specified closure tolerance. Check input data or consider using a lower tolerance standard.</em>
          </div>`;
        }

        const hasCurves = segments.some(s => s.radius > 0 && s.curveDir);

        let tableRows = '';
        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          const lf = metresToLengthFields(seg.chord, unit);
          const displayLen = unit === 'FeetInches' ? `${lf.ft}' ${lf.in}"` : unit === 'DecimalFeet' ? `${lf.ft} ft` : unit === 'Links' ? `${lf.lk} lk` : `${lf.m} m`;

          let curveInfo = '';
          if (hasCurves) {
            if (seg.radius > 0 && seg.curveDir) {
              const theta = arcCentralAngle(seg.chord, seg.radius);
              const arcLen = arcLength(seg.chord, seg.radius);
              const deltaD = (theta * 180 / Math.PI).toFixed(2);
              curveInfo = `<td>${seg.radius.toFixed(2)}</td><td>${seg.curveDir}</td><td>${arcLen.toFixed(3)}</td><td>${deltaD}°</td>`;
            } else {
              curveInfo = '<td>-</td><td>-</td><td>-</td><td>-</td>';
            }
          }

          tableRows += `<tr>
            <td>${i + 1}</td>
            <td>${seg.bearing.toFixed(2)}°</td>
            <td>${decimalToDMS(seg.bearing)}</td>
            <td>${seg.chord.toFixed(3)}</td>
            <td>${displayLen}</td>
            ${curveInfo}
          </tr>`;
        }

        const curveHeaders = hasCurves ? '<th>Radius(m)</th><th>Curve</th><th>Arc Len(m)</th><th>Delta</th>' : '';

        const canvas = document.getElementById('diagramCanvas');
        const diagramImg = canvas.toDataURL('image/png');

        const descHtml = planDesc ? `<div class="print-description no-break"><strong>Description:</strong> ${planDesc}</div>` : '';

        const curveNote = hasCurves ? '<p style="font-size:0.85em;color:#7f8c8d;">* Length column shows chord length for curve segments. Arc length shown separately.</p>' : '';

        // Audit trail - raw input values
        let auditHtml = '';
        if (rawInputs.length > 0) {
          const bt = rawInputs[0].bearingType;
          const lt = rawInputs[0].lengthType;
          const lu = rawInputs[0].lengthUnit;

          let auditRows = '';
          for (let i = 0; i < rawInputs.length; i++) {
            const raw = rawInputs[i];
            const rawBearingStr = formatRawBearing(raw.bearingInput, raw.bearingType);
            const rawLenVal = raw.lengthInput;
            const unitLabel = lu === 'FeetInches' ? 'ft/in' : lu === 'DecimalFeet' ? 'ft' : lu === 'Links' ? 'lk' : 'm';
            const lenLabel = lt === 'arc' && raw.radius > 0 ? 'arc' : 'chord';
            auditRows += `<tr>
              <td>${i + 1}</td>
              <td>${rawBearingStr}</td>
              <td>${rawLenVal.toFixed(3)} ${unitLabel} (${lenLabel})</td>
              <td>${raw.radius > 0 ? raw.radius.toFixed(2) + ' m' : '-'}</td>
              <td>${raw.curveDir || '-'}</td>
            </tr>`;
          }

          const bearingLabel = bt === 'Grads' ? 'Grads' : bt === 'Quadrant' ? 'Quadrant' : bt === 'Internal' ? 'Internal' : bt === 'Deflection' ? 'Deflection' : 'D/M/S';

          auditHtml = `
            <h3>Input Audit Trail</h3>
            <p style="font-size:0.85em;color:#7f8c8d;">Raw values as entered (Bearing: ${bearingLabel}, Length: ${lt === 'arc' ? 'Arc' : 'Chord'} in ${lu})</p>
            <table class="no-break" style="font-size:0.9em;">
              <thead><tr><th>Seg</th><th>Bearing Input</th><th>Length Input</th><th>Radius</th><th>Curve</th></tr></thead>
              <tbody>${auditRows}</tbody>
            </table>
          `;
        }

        return `
          <div class="print-report-header"><h1>Area Calculation Report</h1><h2>Survey Traverse Analysis</h2></div>
          <div class="print-meta">Generated: ${dateStr}</div>
          ${descHtml}
          <div class="print-summary-box no-break">
            <h4>Summary</h4>
            <div class="print-summary-grid">
              <div class="print-summary-item"><span class="print-summary-label">Area:</span><span class="print-summary-value">${areaVals.m2}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Hectares:</span><span class="print-summary-value">${areaVals.ha}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Perimeter:</span><span class="print-summary-value">${perimVals.m}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Sides:</span><span class="print-summary-value">${segments.length}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Status:</span><span class="print-summary-value">${closureStatus}</span></div>
              <div class="print-summary-item"><span class="print-summary-label">Accuracy:</span><span class="print-summary-value">${accuracyRatio}</span></div>
            </div>
          </div>
          <div class="print-diagram-section no-break">
            <img src="${diagramImg}" alt="Survey Diagram">
            <div class="print-diagram-caption">Figure 1: Survey traverse${hasCurves ? ' (curves shown as arcs)' : ''}</div>
          </div>
          <h3>Closure Status</h3>
          ${toleranceHtml}
          ${closureHtml}
          <div class="print-two-column no-break">
            <div class="print-column">
              <h3>Area</h3>
              <ul><li><strong>${areaVals.m2}</strong></li><li>${areaVals.ft2}</li><li>${areaVals.ha}</li><li>${areaVals.acres}</li></ul>
            </div>
            <div class="print-column">
              <h3>Perimeter${hasCurves ? ' (using arc lengths)' : ''}</h3>
              <ul><li><strong>${perimVals.m}</strong></li><li>${perimVals.ft}</li><li>${perimVals.links}</li></ul>
            </div>
          </div>
          <h3>Traverse Schedule</h3>
          <table class="no-break">
            <thead><tr><th>Seg</th><th>Bearing</th><th>DMS</th><th>Chord(m)</th><th>Chord(${unit})</th>${curveHeaders}</tr></thead>
            <tbody>${tableRows}</tbody>
          </table>
          ${curveNote}
          ${auditHtml}
          <div class="print-footer"><div class="print-footer-content"><span>Area Calculator</span><span>Tom Phillips © ${new Date().getFullYear()}</span></div></div>
        `;
      }

      // ============================================
      // EVENT LISTENERS
      // ============================================

      document.getElementById('setSegmentsBtn').addEventListener('click', () => {
        const num = parseInt(document.getElementById('numSegments').value);
        if (isNaN(num) || num < 3) { alert('Min 3 segments.'); return; }
        if (num > 100) { alert('Max 100 segments.'); return; }
        clearSegmentsTable();
        for (let i = 0; i < num; i++) addSegmentRow();
        updateHeaders();
        liveUpdateDiagram();
      });

      document.getElementById('addSegmentBtn').addEventListener('click', () => {
        addSegmentRow();
        triggerLiveUpdate();
      });

      document.getElementById('recalcBtn').addEventListener('click', recalculate);

      ['startBearingDeg', 'startBearingMin', 'startBearingSec'].forEach(id => {
        document.getElementById(id).addEventListener('input', triggerLiveUpdate);
      });

      document.getElementById('bearingType').addEventListener('change', rebuildAllRows);
      document.getElementById('inputUnit').addEventListener('change', rebuildAllRows);
      document.getElementById('angleInputMode').addEventListener('change', () => { updateHeaders(); triggerLiveUpdate(); });

      document.getElementById('saveResultsBtn').addEventListener('click', () => {
        const content = document.getElementById('resultsDisplay').innerText;
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'Area_Report.txt';
        a.click();
      });

      document.getElementById('printPreviewBtn').addEventListener('click', () => window.print());

      // Data persistence buttons
      document.getElementById('exportJsonBtn').addEventListener('click', exportToJson);

      document.getElementById('importJsonBtn').addEventListener('click', () => {
        document.getElementById('importFileInput').click();
      });

      document.getElementById('importFileInput').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          importFromJson(e.target.files[0]);
          e.target.value = ''; // Reset for next import
        }
      });

      document.getElementById('clearStorageBtn').addEventListener('click', () => {
        if (confirm('Clear all saved data? This cannot be undone.')) {
          localStorage.removeItem(STORAGE_KEY);
          alert('Saved data cleared.');
        }
      });

      // Length type change triggers live update
      document.getElementById('lengthType').addEventListener('change', triggerLiveUpdate);

      // ============================================
      // INIT
      // ============================================

      window.onload = () => {
        // Try to load from localStorage first
        if (!loadFromLocalStorage()) {
          // No saved data - set defaults
          document.getElementById('bearingType').value = 'WholeCircle';
          document.getElementById('inputUnit').value = 'Metres';
          document.getElementById('angleInputMode').value = 'Absolute';
          document.getElementById('lengthType').value = 'chord';
          document.getElementById('closureTolerance').value = '10000';
          updateHeaders();
          document.getElementById('setSegmentsBtn').click();
        }
      };

    })();
  </script>
</body>
</html>
