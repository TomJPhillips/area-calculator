<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Area Calculator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: #eef2f3;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    header {
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    h1 { margin: 0; font-size: 2.5em; color: #2c3e50; }
    .beta-note {
      margin: 10px 0 0;
      font-style: italic;
      color: #7f8c8d;
    }
    .controls, .segments, .diagram, .results {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px 20px;
      margin-bottom: 20px;
    }
    .controls label, .controls select, .controls input {
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .controls select,
    .controls input[type="number"],
    .controls input[type="text"],
    textarea {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
    }
    .controls button,
    .segments button,
    .results button {
      padding: 10px 15px;
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.3s ease;
    }
    .controls button:hover,
    .segments button:hover,
    .results button:hover {
      background: #2980b9;
    }
    .controls button:disabled,
    .segments button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
    }
    th { background: #f0f0f0; }
    canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .report h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
      margin-top: 20px;
    }
    textarea {
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .error { border-color: #e74c3c !important; background-color: #fdf2f2 !important; }
    .warning { border-color: #f39c12 !important; background-color: #fef9e7 !important; }

    /* Help tooltips */
    .help-icon {
      display: inline-block;
      width: 18px;
      height: 18px;
      background: #3498db;
      color: #fff;
      border-radius: 50%;
      text-align: center;
      font-size: 12px;
      line-height: 18px;
      cursor: help;
      margin-left: 4px;
      font-weight: bold;
    }
    .help-icon:hover { background: #2980b9; }

    /* Tooltip container */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 280px;
      background-color: #2c3e50;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -140px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.85em;
      line-height: 1.4;
    }
    .tooltip .tooltip-text::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #2c3e50 transparent transparent transparent;
    }
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    /* Error message box */
    .error-box {
      background: #fdf2f2;
      border: 1px solid #e74c3c;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #c0392b;
    }
    .error-box ul {
      margin: 5px 0 0 20px;
      padding: 0;
    }
    .warning-box {
      background: #fef9e7;
      border: 1px solid #f39c12;
      border-radius: 4px;
      padding: 10px 15px;
      margin: 10px 0;
      color: #9a7b0a;
    }

    /* Format hints */
    .format-hint {
      font-size: 0.8em;
      color: #7f8c8d;
      margin-top: 5px;
    }

    /* Report Styles (visible on screen and print) */
    .print-report-header {
      text-align: center;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    .print-report-header h1 {
      font-size: 1.8em;
      color: #2c3e50;
      margin: 0 0 5px 0;
    }
    .print-report-header h2 {
      font-size: 1.1em;
      color: #7f8c8d;
      margin: 0;
      font-weight: 400;
    }
    .print-meta {
      text-align: right;
      font-size: 0.9em;
      color: #7f8c8d;
      margin-bottom: 15px;
    }
    .print-description {
      background: #f8f9fa;
      border-left: 4px solid #3498db;
      padding: 12px 15px;
      margin: 15px 0;
      font-style: italic;
    }
    .print-summary-box {
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
    }
    .print-summary-box h4 {
      margin: 0 0 12px 0;
      color: #2c3e50;
      font-size: 1.1em;
    }
    .print-summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .print-summary-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px dotted #ddd;
    }
    .print-summary-label {
      color: #7f8c8d;
      font-size: 0.9em;
    }
    .print-summary-value {
      font-weight: 600;
      color: #2c3e50;
    }
    .print-diagram-section {
      text-align: center;
      margin: 20px 0;
    }
    .print-diagram-section img {
      max-width: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .print-diagram-caption {
      font-size: 0.85em;
      color: #7f8c8d;
      margin-top: 8px;
      font-style: italic;
    }
    .print-closed-status {
      background: #eafaf1;
      border: 1px solid #27ae60;
      border-radius: 4px;
      padding: 12px 15px;
      margin: 10px 0;
      color: #1e7e34;
    }
    .print-two-column {
      display: flex;
      gap: 30px;
    }
    .print-column {
      flex: 1;
    }
    .print-footer {
      margin-top: 25px;
      padding-top: 12px;
      border-top: 1px solid #ddd;
      font-size: 0.8em;
      color: #7f8c8d;
    }
    .print-footer-content {
      display: flex;
      justify-content: space-between;
    }
    @media (max-width: 600px) {
      .print-two-column {
        flex-direction: column;
        gap: 0;
      }
      .print-summary-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Starting bearing row */
    .starting-bearing-row {
      background: #e8f4f8;
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
    }
    .starting-bearing-row.visible {
      display: block;
    }
    .starting-bearing-row label {
      font-weight: 500;
    }
    .starting-bearing-row input {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
      width: 150px;
    }

    /* Print Styles for Professional A4 Output */
    @media print {
      @page {
        size: A4;
        margin: 15mm 15mm 20mm 15mm;
      }

      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      body {
        margin: 0;
        padding: 0;
        background: #fff !important;
        font-size: 10pt;
        line-height: 1.4;
        color: #000;
      }

      .container {
        width: 100%;
        max-width: none;
        margin: 0;
        padding: 0;
        box-shadow: none;
        background: #fff;
      }

      /* Hide non-print elements */
      header, .controls, .segments, .diagram, .beta-note {
        display: none !important;
      }

      .results {
        border: none;
        margin: 0;
        padding: 0;
        background: #fff;
      }

      .report textarea,
      .report button,
      .report h3:first-of-type {
        display: none !important;
      }

      /* Print Report Wrapper */
      #resultsDisplay {
        font-family: 'Roboto', Arial, sans-serif;
      }

      /* Report Header */
      .print-report-header {
        border-bottom: 3px solid #2c3e50;
        padding-bottom: 15pt;
        margin-bottom: 15pt;
        page-break-after: avoid;
      }

      .print-report-header h1 {
        font-size: 22pt;
        color: #2c3e50;
        margin: 0 0 5pt 0;
        font-weight: 700;
        letter-spacing: -0.5pt;
      }

      .print-report-header h2 {
        font-size: 12pt;
        color: #7f8c8d;
        margin: 0;
        font-weight: 400;
      }

      .print-meta {
        font-size: 9pt;
        color: #7f8c8d;
        text-align: right;
        margin-bottom: 10pt;
      }

      .print-description {
        background: #f8f9fa !important;
        border-left: 4px solid #3498db !important;
        padding: 10pt 12pt;
        margin: 12pt 0;
        font-style: italic;
        font-size: 10pt;
        page-break-inside: avoid;
      }

      /* Section Headers */
      .results h3,
      #resultsDisplay h3 {
        font-size: 12pt;
        color: #2c3e50;
        border-bottom: 1.5pt solid #bdc3c7;
        padding-bottom: 4pt;
        margin: 18pt 0 10pt 0;
        font-weight: 600;
        page-break-after: avoid;
      }

      /* Diagram Section */
      .print-diagram-section {
        text-align: center;
        margin: 15pt 0;
        page-break-inside: avoid;
      }

      .print-diagram-section img {
        max-width: 75%;
        max-height: 280pt;
        border: 1pt solid #ddd;
        border-radius: 4pt;
        margin: 0 auto;
        display: block;
      }

      .print-diagram-caption {
        font-size: 9pt;
        color: #7f8c8d;
        margin-top: 6pt;
        font-style: italic;
      }

      /* Two Column Layout for Area/Perimeter */
      .print-two-column {
        display: flex;
        gap: 20pt;
        page-break-inside: avoid;
      }

      .print-column {
        flex: 1;
      }

      /* Lists */
      #resultsDisplay ul {
        margin: 8pt 0;
        padding-left: 0;
        list-style: none;
      }

      #resultsDisplay ul li {
        padding: 3pt 0;
        font-size: 10pt;
        border-bottom: 0.5pt dotted #ddd;
      }

      #resultsDisplay ul li:last-child {
        border-bottom: none;
      }

      #resultsDisplay ul li strong {
        color: #2c3e50;
      }

      /* Tables */
      #resultsDisplay table {
        width: 100%;
        border-collapse: collapse;
        margin: 10pt 0;
        font-size: 9pt;
        page-break-inside: avoid;
      }

      #resultsDisplay table thead {
        background: #2c3e50 !important;
      }

      #resultsDisplay table th {
        background: #2c3e50 !important;
        color: #fff !important;
        padding: 8pt 6pt;
        font-weight: 600;
        text-align: center;
        border: 1pt solid #2c3e50;
      }

      #resultsDisplay table td {
        padding: 6pt;
        text-align: center;
        border: 0.5pt solid #ddd;
      }

      #resultsDisplay table tbody tr:nth-child(even) {
        background: #f8f9fa !important;
      }

      #resultsDisplay table tbody tr:hover {
        background: none;
      }

      /* Closure Status Boxes */
      .warning-box {
        background: #fef9e7 !important;
        border: 1.5pt solid #f39c12 !important;
        border-radius: 4pt;
        padding: 10pt 12pt;
        margin: 10pt 0;
        page-break-inside: avoid;
      }

      .print-closed-status {
        background: #eafaf1 !important;
        border: 1.5pt solid #27ae60 !important;
        border-radius: 4pt;
        padding: 10pt 12pt;
        margin: 10pt 0;
        color: #1e7e34;
        page-break-inside: avoid;
      }

      /* Footer */
      .print-footer {
        margin-top: 20pt;
        padding-top: 10pt;
        border-top: 1pt solid #bdc3c7;
        font-size: 8pt;
        color: #7f8c8d;
        text-align: center;
        page-break-inside: avoid;
      }

      .print-footer-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Page Break Controls */
      .page-break-before {
        page-break-before: always;
      }

      .page-break-after {
        page-break-after: always;
      }

      .no-break {
        page-break-inside: avoid;
      }

      /* Ensure proper orphan/widow control */
      p, li {
        orphans: 3;
        widows: 3;
      }

      h3 {
        page-break-after: avoid;
      }

      /* Summary Box */
      .print-summary-box {
        background: #f8f9fa !important;
        border: 1pt solid #ddd;
        border-radius: 4pt;
        padding: 12pt;
        margin: 12pt 0;
        page-break-inside: avoid;
      }

      .print-summary-box h4 {
        margin: 0 0 8pt 0;
        font-size: 11pt;
        color: #2c3e50;
      }

      .print-summary-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8pt;
      }

      .print-summary-item {
        display: flex;
        justify-content: space-between;
        padding: 4pt 0;
        border-bottom: 0.5pt dotted #ddd;
      }

      .print-summary-label {
        color: #7f8c8d;
        font-size: 9pt;
      }

      .print-summary-value {
        font-weight: 600;
        color: #2c3e50;
        font-size: 10pt;
      }
    }

    @media (max-width: 768px) {
      .controls, .segments, .diagram, .results { padding: 10px; }
      h1 { font-size: 2em; }
      .tooltip .tooltip-text { width: 200px; margin-left: -100px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Area Calculator</h1>
      <p class="beta-note">Test version - message Tom Phillips with any bugs/improvement ideas</p>
    </header>

    <!-- Top Controls -->
    <div class="controls">
      <label for="inputUnit">Distance Unit:</label>
      <select id="inputUnit">
        <option value="Metres" selected>Metres</option>
        <option value="DecimalFeet">Decimal Feet</option>
        <option value="FeetInches">Feet and Inches</option>
        <option value="Links">Links</option>
      </select>
      <span class="tooltip">
        <span class="help-icon">?</span>
        <span class="tooltip-text">
          <strong>Metres:</strong> Enter as decimal (e.g., 10.5)<br>
          <strong>Decimal Feet:</strong> Enter as decimal (e.g., 32.8)<br>
          <strong>Feet and Inches:</strong> Enter as 10' 6" or 10' 6.5"<br>
          <strong>Links:</strong> 1 link = 0.201168m (Gunter's chain)
        </span>
      </span>

      <label for="bearingType" style="margin-left: 15px;">Bearing Type:</label>
      <select id="bearingType">
        <option value="WholeCircle" selected>Whole Circle Bearings</option>
        <option value="DecimalDegrees">Decimal Degrees</option>
        <option value="Quadrant">Quadrant Bearings</option>
        <option value="Internal">Internal Angles</option>
        <option value="Deflection">Deflection Angles</option>
        <option value="Grads">Grads</option>
      </select>
      <span class="tooltip">
        <span class="help-icon">?</span>
        <span class="tooltip-text">
          <strong>Whole Circle:</strong> 0-360° clockwise from North<br>
          <strong>Decimal Degrees:</strong> Same as Whole Circle<br>
          <strong>Quadrant:</strong> N45°E, S30°W format<br>
          <strong>Internal:</strong> Interior angles of polygon (needs starting bearing)<br>
          <strong>Deflection:</strong> Turn angle from previous line (+ve=right, -ve=left)<br>
          <strong>Grads:</strong> 0-400 grads (100 grads = 90°)
        </span>
      </span>

      <br><br>

      <label for="angleInputMode">Angle Input Mode:</label>
      <select id="angleInputMode">
        <option value="Absolute" selected>Absolute</option>
        <option value="Relative">Relative (cumulative)</option>
      </select>
      <span class="tooltip">
        <span class="help-icon">?</span>
        <span class="tooltip-text">
          <strong>Absolute:</strong> Each bearing is independent (e.g., segment 1 = 45°, segment 2 = 135°)<br>
          <strong>Relative:</strong> Each bearing adds to the previous (e.g., start at 45°, turn +90° = 135°)
        </span>
      </span>

      <label for="outputArea" style="margin-left: 15px;">Output Area Unit:</label>
      <select id="outputArea">
        <option value="m2" selected>m²</option>
        <option value="ha">ha</option>
        <option value="acres">acres</option>
        <option value="ft2">ft²</option>
        <option value="km2">km²</option>
        <option value="roods">roods</option>
        <option value="perches">perches</option>
      </select>

      <br><br>
      <label for="numSegments"># Segments:</label>
      <input type="number" id="numSegments" value="4" min="3" max="100" style="width:70px;">
      <button id="setSegmentsBtn">Set Segments</button>
      <button id="recalcBtn">Recalculate</button>
    </div>

    <!-- Segment Input Table -->
    <div class="segments">
      <h3>Survey Segments</h3>

      <!-- Starting bearing for Internal/Deflection angles -->
      <div id="startingBearingRow" class="starting-bearing-row">
        <label for="startingBearing">Starting Bearing (first segment direction):</label>
        <input type="text" id="startingBearing" value="0" placeholder="e.g., 0 or 45.5">
        <span class="tooltip">
          <span class="help-icon">?</span>
          <span class="tooltip-text">
            For Internal/Deflection angles, enter the absolute bearing of the first segment (degrees clockwise from North). Subsequent angles will be calculated relative to this.
          </span>
        </span>
        <span class="format-hint" id="startingBearingHint">Enter degrees (0-360)</span>
      </div>

      <div id="validationErrors"></div>

      <table id="segmentsTable">
        <thead>
          <tr>
            <th style="width: 50px;">No.</th>
            <th>
              Bearing / Angle
              <span class="tooltip">
                <span class="help-icon">?</span>
                <span class="tooltip-text" id="bearingTooltip">Enter bearing in the selected format</span>
              </span>
              <div class="format-hint" id="bearingFormatHint">Format: 0-360°</div>
            </th>
            <th>
              Length
              <div class="format-hint" id="lengthFormatHint">Format: decimal metres</div>
            </th>
            <th style="width: 60px;">
              Flip
              <span class="tooltip">
                <span class="help-icon">?</span>
                <span class="tooltip-text">Reverses the bearing by 180° (points the segment in the opposite direction)</span>
              </span>
            </th>
            <th style="width: 60px;">Delete</th>
          </tr>
        </thead>
        <tbody>
          <!-- Segment rows will be generated here -->
        </tbody>
      </table>
      <br>
      <button id="addSegmentBtn">Add Segment</button>
    </div>

    <!-- Diagram -->
    <div class="diagram">
      <h3>Survey Diagram</h3>
      <canvas id="diagramCanvas" width="500" height="500"></canvas>
    </div>

    <!-- Results & Report -->
    <div class="results">
      <div id="resultsDisplay">
        <p style="color: #7f8c8d; font-style: italic;">Enter at least 3 segments and click "Recalculate" to see results.</p>
      </div>
      <div class="report">
        <h3>Plan Description & Measurements</h3>
        <textarea id="planDescription" rows="3" placeholder="Add a brief description of this plan..."></textarea>
        <br>
        <button id="saveResultsBtn">Save Results</button>
        <button id="printPreviewBtn">Print Preview</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * Area Calculator - Survey Polygon Area Tool
     * Calculates enclosed area from bearing and distance measurements.
     *
     * Supported bearing types:
     * - Whole Circle Bearings (0-360° clockwise from North)
     * - Decimal Degrees (same as Whole Circle)
     * - Quadrant Bearings (N45°E format)
     * - Internal Angles (interior angles with starting bearing)
     * - Deflection Angles (turn angles: +ve right, -ve left)
     * - Grads (0-400, where 100 grads = 90°)
     */
    (function() {
      'use strict';

      // ============================================
      // CONSTANTS
      // ============================================
      const TOLERANCE = 1e-6;
      const GRADS_TO_DEGREES = 0.9; // 360/400
      const LINK_TO_METRES = 0.201168;
      const FEET_TO_METRES = 0.3048;
      const INCH_TO_METRES = 0.0254;

      // ============================================
      // UTILITY: Debounce
      // ============================================
      let debounceTimer = null;
      function debounce(fn, delay = 200) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(fn, delay);
      }

      // ============================================
      // UTILITY: Angle Conversion Functions
      // ============================================

      /**
       * Convert degrees, minutes, seconds to decimal degrees
       */
      function dmsToDecimal(deg, min, sec) {
        const sign = deg < 0 ? -1 : 1;
        return sign * (Math.abs(parseFloat(deg)) + parseFloat(min) / 60 + parseFloat(sec) / 3600);
      }

      /**
       * Parse a DMS string (e.g., "45d 30m 15s" or "45° 30' 15\"")
       * Returns decimal degrees
       */
      function parseDMS(bearingStr) {
        bearingStr = bearingStr.trim();

        // If it's already a plain number, return it
        if (!isNaN(bearingStr) && bearingStr !== '') {
          return parseFloat(bearingStr);
        }

        // Try to match DMS format: 45d 30m 15s or 45° 30' 15"
        const regex = /^(-?\d+(?:\.\d+)?)[d°]\s*(\d+(?:\.\d+)?)?[m']?\s*([\d.]+)?[s"]?$/i;
        const match = bearingStr.match(regex);

        if (!match) {
          throw new Error(`Invalid DMS format: "${bearingStr}". Use format like "45d 30m 15s" or just decimal degrees.`);
        }

        const deg = match[1] || 0;
        const min = match[2] || 0;
        const sec = match[3] || 0;

        return dmsToDecimal(deg, min, sec);
      }

      /**
       * Parse quadrant bearing (e.g., "N45°E", "S 30 W")
       * Returns decimal degrees (0-360 clockwise from North)
       */
      function parseQuadrantBearing(bearingStr) {
        bearingStr = bearingStr.trim().toUpperCase();

        // Match patterns like: N45E, N 45° E, N45°E, S30W, etc.
        const regex = /^(N|S)\s*(\d+(?:\.\d+)?)\s*°?\s*(E|W)$/;
        const match = bearingStr.match(regex);

        if (!match) {
          throw new Error(`Invalid quadrant bearing: "${bearingStr}". Use format like "N45°E" or "S30°W".`);
        }

        const ns = match[1];
        const angle = parseFloat(match[2]);
        const ew = match[3];

        // Validate angle is in range 0-90
        if (angle < 0 || angle > 90) {
          throw new Error(`Quadrant angle must be 0-90°. Got: ${angle}°`);
        }

        // Convert to whole circle bearing
        if (ns === 'N' && ew === 'E') return angle;
        if (ns === 'N' && ew === 'W') return 360 - angle;
        if (ns === 'S' && ew === 'E') return 180 - angle;
        if (ns === 'S' && ew === 'W') return 180 + angle;

        throw new Error(`Invalid quadrant bearing: "${bearingStr}"`);
      }

      /**
       * Convert decimal degrees to DMS string
       */
      function decimalToDMS(bearing) {
        const sign = bearing < 0 ? '-' : '';
        const absBearing = Math.abs(bearing);
        const degrees = Math.floor(absBearing);
        const minFloat = (absBearing - degrees) * 60;
        const minutes = Math.floor(minFloat);
        const seconds = ((minFloat - minutes) * 60).toFixed(1);
        return `${sign}${degrees}° ${minutes}' ${seconds}"`;
      }

      /**
       * Convert decimal degrees to quadrant bearing string
       */
      function decimalToQuadrant(bearing) {
        // Normalize to 0-360
        bearing = ((bearing % 360) + 360) % 360;

        if (bearing <= 90) {
          return `N${bearing.toFixed(1)}°E`;
        } else if (bearing <= 180) {
          return `S${(180 - bearing).toFixed(1)}°E`;
        } else if (bearing <= 270) {
          return `S${(bearing - 180).toFixed(1)}°W`;
        } else {
          return `N${(360 - bearing).toFixed(1)}°W`;
        }
      }

      /**
       * Normalize bearing to 0-360 range
       */
      function normalizeBearing(bearing) {
        return ((bearing % 360) + 360) % 360;
      }

      // ============================================
      // UTILITY: Length Conversion Functions
      // ============================================

      /**
       * Parse metric length (metres)
       */
      function parseMetricLength(lengthStr) {
        const value = parseFloat(lengthStr);
        if (isNaN(value)) {
          throw new Error(`Invalid metric length: "${lengthStr}". Enter a number.`);
        }
        if (value <= 0) {
          throw new Error(`Length must be positive. Got: ${value}`);
        }
        return value;
      }

      /**
       * Parse decimal feet, convert to metres
       */
      function parseDecimalFeet(lengthStr) {
        const value = parseFloat(lengthStr);
        if (isNaN(value)) {
          throw new Error(`Invalid decimal feet: "${lengthStr}". Enter a number.`);
        }
        if (value <= 0) {
          throw new Error(`Length must be positive. Got: ${value}`);
        }
        return value * FEET_TO_METRES;
      }

      /**
       * Parse feet and inches (e.g., "10' 6\"" or "10'6" or "10 6")
       * Convert to metres
       */
      function parseImperialLength(lengthStr) {
        lengthStr = lengthStr.trim();

        // Try various formats: 10' 6", 10'6", 10' 6, 10 6
        const regex = /^(\d+(?:\.\d+)?)\s*['\s]+\s*([\d.]+)\s*"?$/;
        const match = lengthStr.match(regex);

        if (!match) {
          // Try feet-only format: 10' or 10
          const feetOnly = /^(\d+(?:\.\d+)?)\s*'?$/.exec(lengthStr);
          if (feetOnly) {
            const feet = parseFloat(feetOnly[1]);
            if (feet <= 0) throw new Error(`Length must be positive. Got: ${feet}`);
            return feet * FEET_TO_METRES;
          }
          throw new Error(`Invalid feet/inches format: "${lengthStr}". Use format like "10' 6\\"" or "10' 6".`);
        }

        const feet = parseFloat(match[1]);
        const inches = parseFloat(match[2]);

        if (inches >= 12) {
          throw new Error(`Inches must be less than 12. Got: ${inches}`);
        }

        const totalMetres = feet * FEET_TO_METRES + inches * INCH_TO_METRES;
        if (totalMetres <= 0) {
          throw new Error(`Length must be positive.`);
        }
        return totalMetres;
      }

      /**
       * Parse links (Gunter's chain), convert to metres
       */
      function parseLinkLength(lengthStr) {
        const value = parseFloat(lengthStr);
        if (isNaN(value)) {
          throw new Error(`Invalid link value: "${lengthStr}". Enter a number.`);
        }
        if (value <= 0) {
          throw new Error(`Length must be positive. Got: ${value}`);
        }
        return value * LINK_TO_METRES;
      }

      // ============================================
      // GEOMETRY: Coordinate and Area Functions
      // ============================================

      /**
       * Compute Cartesian coordinates from segments
       * Each segment has: { bearing: degrees, length_m: metres }
       * Returns array of points: [{ x, y }, ...]
       *
       * Convention: North = +Y, East = +X
       * Bearing = clockwise from North
       */
      function computeCoordinates(segments) {
        const points = [{ x: 0, y: 0 }];
        let x = 0, y = 0;

        for (const seg of segments) {
          const rad = seg.bearing * Math.PI / 180;
          // sin for East (X), cos for North (Y)
          const dx = seg.length_m * Math.sin(rad);
          const dy = seg.length_m * Math.cos(rad);
          x += dx;
          y += dy;
          points.push({ x, y });
        }

        return points;
      }

      /**
       * Compute area using Shoelace formula
       * Works for any simple polygon (no self-intersection)
       * Returns area in square metres
       */
      function computeArea(points) {
        if (points.length < 3) return 0;

        let area = 0;
        const n = points.length;

        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          area += points[i].x * points[j].y;
          area -= points[j].x * points[i].y;
        }

        return Math.abs(area) / 2;
      }

      /**
       * Compute total perimeter from segments
       */
      function computePerimeter(segments) {
        return segments.reduce((sum, seg) => sum + seg.length_m, 0);
      }

      /**
       * Compute misclosure (gap between last point and first point)
       * Returns null if shape is closed within tolerance
       * Otherwise returns { length_m, bearing }
       */
      function computeMisclosure(points) {
        if (points.length < 2) return null;

        const first = points[0];
        const last = points[points.length - 1];
        const dx = first.x - last.x;
        const dy = first.y - last.y;
        const length = Math.hypot(dx, dy);

        if (length < TOLERANCE) {
          return null; // Closed within tolerance
        }

        // Bearing from last point to first point
        const bearing = normalizeBearing(Math.atan2(dx, dy) * 180 / Math.PI);

        return { length_m: length, bearing };
      }

      // ============================================
      // CONVERSION: Output Report Values
      // ============================================

      function convertAreaValues(m2) {
        return {
          m2: m2.toFixed(2) + ' m²',
          ft2: (m2 * 10.7639).toFixed(2) + ' ft²',
          ha: (m2 / 10000).toFixed(4) + ' ha',
          acres: (m2 * 0.000247105).toFixed(4) + ' acres',
          km2: (m2 / 1e6).toFixed(6) + ' km²',
          sqmi: (m2 / 2589988.11).toFixed(6) + ' sq mi',
          perches: (m2 / 25.2929).toFixed(2) + ' perches',
          roods: (m2 / 1011.7141).toFixed(4) + ' roods'
        };
      }

      function convertPerimeterValues(m) {
        return {
          m: m.toFixed(2) + ' m',
          ft: (m * 3.28084).toFixed(2) + ' ft',
          links: (m / LINK_TO_METRES).toFixed(2) + ' links',
          km: (m / 1000).toFixed(3) + ' km',
          miles: (m / 1609.34).toFixed(3) + ' mi'
        };
      }

      // ============================================
      // DIAGRAM: Canvas Drawing
      // ============================================

      /**
       * Draw the survey diagram on canvas
       * @param {Array} points - Array of {x, y} coordinates
       * @param {Object|null} misclosure - Misclosure info or null if closed
       * @param {Object} options - Drawing options
       * @param {boolean} options.allowFill - Whether to fill the polygon (default: true)
       */
      function drawDiagram(points, misclosure, options = {}) {
        const { allowFill = true } = options;
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (points.length < 2) {
          ctx.fillStyle = '#7f8c8d';
          ctx.font = '14px Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Not enough points to draw', canvas.width / 2, canvas.height / 2);
          return;
        }

        // Compute bounds
        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const padding = 40;
        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        const scaleX = (canvas.width - 2 * padding) / rangeX;
        const scaleY = (canvas.height - 2 * padding) / rangeY;
        const scale = Math.min(scaleX, scaleY);

        // Center the drawing
        const offsetX = (canvas.width - rangeX * scale) / 2 - minX * scale;
        const offsetY = (canvas.height - rangeY * scale) / 2 + maxY * scale;

        // Convert survey coordinates to canvas coordinates
        // Survey: +Y is North (up), +X is East (right)
        // Canvas: +Y is down, +X is right
        function toCanvas(p) {
          return {
            x: p.x * scale + offsetX,
            y: -p.y * scale + offsetY
          };
        }

        const cPoints = points.map(toCanvas);

        // Draw filled polygon (light fill) only if allowed and closed
        if (allowFill && points.length >= 3 && !misclosure) {
          ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
          ctx.beginPath();
          ctx.moveTo(cPoints[0].x, cPoints[0].y);
          for (let i = 1; i < cPoints.length; i++) {
            ctx.lineTo(cPoints[i].x, cPoints[i].y);
          }
          ctx.closePath();
          ctx.fill();
        }

        // Draw segments
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cPoints[0].x, cPoints[0].y);
        for (let i = 1; i < cPoints.length; i++) {
          ctx.lineTo(cPoints[i].x, cPoints[i].y);
        }

        // If closed, close the path; otherwise draw dashed closing line
        if (!misclosure) {
          ctx.closePath();
          ctx.stroke();
        } else {
          ctx.stroke();

          // Draw misclosure line (dashed, red)
          ctx.strokeStyle = '#e74c3c';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cPoints[cPoints.length - 1].x, cPoints[cPoints.length - 1].y);
          ctx.lineTo(cPoints[0].x, cPoints[0].y);
          ctx.stroke();
          ctx.setLineDash([]);

          // Draw arrowhead on misclosure line
          const lastC = cPoints[cPoints.length - 1];
          const firstC = cPoints[0];
          const angle = Math.atan2(firstC.y - lastC.y, firstC.x - lastC.x);
          const arrowLen = 10;

          ctx.fillStyle = '#e74c3c';
          ctx.beginPath();
          ctx.moveTo(firstC.x, firstC.y);
          ctx.lineTo(
            firstC.x - arrowLen * Math.cos(angle - Math.PI / 6),
            firstC.y - arrowLen * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            firstC.x - arrowLen * Math.cos(angle + Math.PI / 6),
            firstC.y - arrowLen * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();
        }

        // Draw vertices
        ctx.fillStyle = '#2c3e50';
        for (let i = 0; i < cPoints.length; i++) {
          ctx.beginPath();
          ctx.arc(cPoints[i].x, cPoints[i].y, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Label segment midpoints with segment numbers
        ctx.fillStyle = '#2980b9';
        ctx.font = 'bold 14px Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (let i = 0; i < cPoints.length - 1; i++) {
          const midX = (cPoints[i].x + cPoints[i + 1].x) / 2;
          const midY = (cPoints[i].y + cPoints[i + 1].y) / 2;

          // Offset label slightly perpendicular to the line
          const dx = cPoints[i + 1].x - cPoints[i].x;
          const dy = cPoints[i + 1].y - cPoints[i].y;
          const len = Math.hypot(dx, dy) || 1;
          const offsetDist = 15;
          const perpX = -dy / len * offsetDist;
          const perpY = dx / len * offsetDist;

          ctx.fillText((i + 1).toString(), midX + perpX, midY + perpY);
        }

        // Draw North arrow
        ctx.save();
        ctx.translate(canvas.width - 30, 30);
        ctx.strokeStyle = '#2c3e50';
        ctx.fillStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 20);
        ctx.lineTo(0, -15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(-5, -5);
        ctx.lineTo(5, -5);
        ctx.closePath();
        ctx.fill();
        ctx.font = 'bold 12px Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('N', 0, -22);
        ctx.restore();
      }

      // ============================================
      // LIVE UPDATE: Diagram updates while typing
      // ============================================

      // Reference to segment table body (used by live update and UI functions)
      const segmentsTableBody = document.querySelector('#segmentsTable tbody');

      /**
       * Parse segments permissively for live preview.
       * Stops at first invalid row rather than blocking.
       * Returns array of valid segments up to first error.
       */
      function parseSegmentsPermissive() {
        const inputUnit = document.getElementById('inputUnit').value;
        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const rows = segmentsTableBody.querySelectorAll('tr');

        const segments = [];
        let currentBearing = 0;

        // Parse starting bearing for Internal/Deflection modes
        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          try {
            currentBearing = parseDMS(document.getElementById('startingBearing').value);
            currentBearing = normalizeBearing(currentBearing);
          } catch (e) {
            return segments; // Can't proceed without valid starting bearing
          }
        }

        // Parse each row, stopping at first error
        for (let idx = 0; idx < rows.length; idx++) {
          const row = rows[idx];
          const bearingInput = row.children[1].firstChild;
          const lengthInput = row.children[2].firstChild;

          let bearing, length;

          // Try to parse bearing
          try {
            const rawBearing = parseBearingValue(bearingInput.value, bearingType);

            if (bearingType === 'Internal') {
              if (idx === 0) {
                bearing = currentBearing;
              } else {
                const internalAngle = rawBearing;
                const deflection = 180 - internalAngle;
                currentBearing = normalizeBearing(currentBearing + deflection);
                bearing = currentBearing;
              }
            } else if (bearingType === 'Deflection') {
              if (idx === 0) {
                bearing = normalizeBearing(currentBearing + rawBearing);
                currentBearing = bearing;
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
                bearing = currentBearing;
              }
            } else if (angleInputMode === 'Relative') {
              if (idx === 0) {
                currentBearing = normalizeBearing(rawBearing);
              } else {
                currentBearing = normalizeBearing(currentBearing + rawBearing);
              }
              bearing = currentBearing;
            } else {
              bearing = normalizeBearing(rawBearing);
            }
          } catch (e) {
            break; // Stop at first invalid bearing
          }

          // Try to parse length
          try {
            length = parseLengthValue(lengthInput.value, inputUnit);
          } catch (e) {
            break; // Stop at first invalid length
          }

          segments.push({ bearing, length_m: length });
        }

        return segments;
      }

      /**
       * Live update diagram without blocking on errors.
       * Draws partial polyline up to first invalid row.
       */
      function liveUpdateDiagram() {
        const segments = parseSegmentsPermissive();
        const points = computeCoordinates(segments);

        // Only compute misclosure and allow fill if we have 3+ valid segments
        const canClose = segments.length >= 3;
        const misclosure = canClose ? computeMisclosure(points) : { length_m: 1 }; // Force "open" if < 3
        const allowFill = canClose && !misclosure;

        drawDiagram(points, canClose ? misclosure : null, { allowFill });
      }

      /**
       * Debounced version of liveUpdateDiagram for smooth typing
       */
      function triggerLiveUpdate() {
        debounce(liveUpdateDiagram, 150);
      }

      // ============================================
      // UI: Segment Table Management
      // ============================================

      function clearSegmentsTable() {
        segmentsTableBody.innerHTML = '';
      }

      /**
       * Get default values based on current settings to create a closed square
       */
      function getDefaultSegmentValues(segmentIndex, totalSegments) {
        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const inputUnit = document.getElementById('inputUnit').value;

        // Default length based on unit
        let defaultLength;
        switch (inputUnit) {
          case 'Metres': defaultLength = '10.0'; break;
          case 'DecimalFeet': defaultLength = '32.81'; break;
          case 'FeetInches': defaultLength = "32' 10\""; break;
          case 'Links': defaultLength = '49.71'; break;
          default: defaultLength = '10.0';
        }

        // Calculate bearing to create a closed square (or reasonable polygon)
        let defaultBearing;

        if (bearingType === 'Internal') {
          // For internal angles of a square: 90° each
          defaultBearing = '90';
        } else if (bearingType === 'Deflection') {
          // For deflection angles of a square: turn 90° right each time
          defaultBearing = segmentIndex === 0 ? '0' : '90';
        } else if (bearingType === 'Quadrant') {
          // Create a square with quadrant bearings
          const bearings = ['N0°E', 'N90°E', 'S0°E', 'N90°W'];
          defaultBearing = bearings[segmentIndex % 4];
        } else if (bearingType === 'Grads') {
          // Grads equivalent of square bearings
          const gradBearings = [0, 100, 200, 300];
          defaultBearing = gradBearings[segmentIndex % 4].toString();
        } else {
          // Whole circle / decimal degrees - create a square
          if (angleInputMode === 'Relative') {
            defaultBearing = segmentIndex === 0 ? '0' : '90';
          } else {
            const bearings = [0, 90, 180, 270];
            defaultBearing = bearings[segmentIndex % 4].toString();
          }
        }

        return { bearing: defaultBearing, length: defaultLength };
      }

      function addSegmentRow(bearing = null, length = null) {
        const rowIndex = segmentsTableBody.querySelectorAll('tr').length;
        const totalSegments = parseInt(document.getElementById('numSegments').value) || 4;
        const defaults = getDefaultSegmentValues(rowIndex, totalSegments);

        const row = document.createElement('tr');

        // Segment number cell
        const cellNo = document.createElement('td');
        cellNo.textContent = (rowIndex + 1).toString();
        row.appendChild(cellNo);

        // Bearing input cell
        const cellBearing = document.createElement('td');
        const inputBearing = document.createElement('input');
        inputBearing.type = 'text';
        inputBearing.value = bearing !== null ? bearing : defaults.bearing;
        inputBearing.style.width = '95%';
        inputBearing.placeholder = getPlaceholderForBearingType();
        inputBearing.addEventListener('input', (e) => {
          clearInputError(e);
          triggerLiveUpdate();
        });
        cellBearing.appendChild(inputBearing);
        row.appendChild(cellBearing);

        // Length input cell
        const cellLength = document.createElement('td');
        const inputLength = document.createElement('input');
        inputLength.type = 'text';
        inputLength.value = length !== null ? length : defaults.length;
        inputLength.style.width = '95%';
        inputLength.placeholder = getPlaceholderForLengthUnit();
        inputLength.addEventListener('input', (e) => {
          clearInputError(e);
          triggerLiveUpdate();
        });
        cellLength.appendChild(inputLength);
        row.appendChild(cellLength);

        // Flip button cell
        const cellFlip = document.createElement('td');
        const flipBtn = document.createElement('button');
        flipBtn.textContent = 'Flip';
        flipBtn.title = 'Reverse bearing by 180°';
        flipBtn.addEventListener('click', () => flipSegment(row));
        cellFlip.appendChild(flipBtn);
        row.appendChild(cellFlip);

        // Delete button cell
        const cellDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'X';
        delBtn.title = 'Delete this segment';
        delBtn.style.background = '#e74c3c';
        delBtn.addEventListener('click', () => {
          row.remove();
          updateSegmentNumbers();
          triggerLiveUpdate();
        });
        cellDel.appendChild(delBtn);
        row.appendChild(cellDel);

        segmentsTableBody.appendChild(row);
        updateSegmentNumbers();
      }

      function updateSegmentNumbers() {
        const rows = segmentsTableBody.querySelectorAll('tr');
        rows.forEach((row, idx) => {
          row.firstChild.textContent = (idx + 1).toString();
        });
      }

      function clearInputError(e) {
        e.target.classList.remove('error');
      }

      function getPlaceholderForBearingType() {
        const bearingType = document.getElementById('bearingType').value;
        switch (bearingType) {
          case 'Quadrant': return 'e.g., N45°E';
          case 'Internal': return 'e.g., 90';
          case 'Deflection': return 'e.g., +90 or -45';
          case 'Grads': return 'e.g., 100';
          default: return 'e.g., 45.5';
        }
      }

      function getPlaceholderForLengthUnit() {
        const inputUnit = document.getElementById('inputUnit').value;
        switch (inputUnit) {
          case 'DecimalFeet': return 'e.g., 32.81';
          case 'FeetInches': return "e.g., 10' 6\"";
          case 'Links': return 'e.g., 49.71';
          default: return 'e.g., 10.5';
        }
      }

      // ============================================
      // UI: Update Format Hints
      // ============================================

      function updateFormatHints() {
        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const inputUnit = document.getElementById('inputUnit').value;

        // Update bearing format hint
        const bearingHint = document.getElementById('bearingFormatHint');
        const bearingTooltip = document.getElementById('bearingTooltip');

        let bearingHintText, bearingTooltipText;
        switch (bearingType) {
          case 'Quadrant':
            bearingHintText = 'Format: N45°E, S30°W';
            bearingTooltipText = 'Quadrant bearings: direction from N or S, angle 0-90°, then E or W. Example: N45°E means 45° east of north.';
            break;
          case 'Internal':
            bearingHintText = 'Format: interior angle (0-180°)';
            bearingTooltipText = 'Internal angles: the interior angle of the polygon at each vertex. For a square, use 90°. For a regular hexagon, use 120°.';
            break;
          case 'Deflection':
            bearingHintText = 'Format: turn angle (+right, -left)';
            bearingTooltipText = 'Deflection angles: how much you turn from the previous line. Positive = turn right, Negative = turn left. For a square turning right, use +90.';
            break;
          case 'Grads':
            bearingHintText = 'Format: 0-400 grads';
            bearingTooltipText = 'Grads (gradians): 0 = North, 100 = East, 200 = South, 300 = West. 400 grads = 360°.';
            break;
          default:
            bearingHintText = angleInputMode === 'Relative'
              ? 'Format: degrees (first is absolute, rest are cumulative)'
              : 'Format: 0-360° from North';
            bearingTooltipText = 'Whole circle bearing: degrees clockwise from North. 0° = North, 90° = East, 180° = South, 270° = West.';
        }
        bearingHint.textContent = bearingHintText;
        bearingTooltip.textContent = bearingTooltipText;

        // Update length format hint
        const lengthHint = document.getElementById('lengthFormatHint');
        switch (inputUnit) {
          case 'DecimalFeet':
            lengthHint.textContent = 'Format: decimal feet (e.g., 32.81)';
            break;
          case 'FeetInches':
            lengthHint.textContent = "Format: feet' inches\" (e.g., 10' 6\")";
            break;
          case 'Links':
            lengthHint.textContent = 'Format: links (1 link = 0.201m)';
            break;
          default:
            lengthHint.textContent = 'Format: decimal metres (e.g., 10.5)';
        }

        // Show/hide starting bearing row for Internal and Deflection angles
        const startingBearingRow = document.getElementById('startingBearingRow');
        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          startingBearingRow.classList.add('visible');
        } else {
          startingBearingRow.classList.remove('visible');
        }

        // Update placeholders in existing rows
        const rows = segmentsTableBody.querySelectorAll('tr');
        rows.forEach(row => {
          const bearingInput = row.children[1].firstChild;
          const lengthInput = row.children[2].firstChild;
          bearingInput.placeholder = getPlaceholderForBearingType();
          lengthInput.placeholder = getPlaceholderForLengthUnit();
        });
      }

      // ============================================
      // CALCULATION: Parse and Compute
      // ============================================

      /**
       * Parse a bearing value based on current bearing type
       * Returns decimal degrees (0-360)
       */
      function parseBearingValue(value, bearingType) {
        value = value.trim();

        if (value === '') {
          throw new Error('Bearing is required');
        }

        let degrees;

        switch (bearingType) {
          case 'Quadrant':
            degrees = parseQuadrantBearing(value);
            break;
          case 'Grads':
            const grads = parseFloat(value);
            if (isNaN(grads)) {
              throw new Error(`Invalid grads value: "${value}"`);
            }
            degrees = grads * GRADS_TO_DEGREES;
            break;
          case 'Internal':
          case 'Deflection':
          case 'WholeCircle':
          case 'DecimalDegrees':
          default:
            degrees = parseDMS(value);
            break;
        }

        return degrees;
      }

      /**
       * Parse length value based on current unit
       * Returns metres
       */
      function parseLengthValue(value, inputUnit) {
        value = value.trim();

        if (value === '') {
          throw new Error('Length is required');
        }

        switch (inputUnit) {
          case 'DecimalFeet':
            return parseDecimalFeet(value);
          case 'FeetInches':
            return parseImperialLength(value);
          case 'Links':
            return parseLinkLength(value);
          case 'Metres':
          default:
            return parseMetricLength(value);
        }
      }

      /**
       * Validate all inputs and return parsed segments
       * Returns { valid: boolean, segments: [], errors: [] }
       */
      function validateAndParseInputs() {
        const inputUnit = document.getElementById('inputUnit').value;
        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const rows = segmentsTableBody.querySelectorAll('tr');

        const errors = [];
        const segments = [];
        let currentBearing = 0;

        // Clear previous error highlights
        rows.forEach(row => {
          row.children[1].firstChild.classList.remove('error');
          row.children[2].firstChild.classList.remove('error');
        });
        document.getElementById('startingBearing').classList.remove('error');

        // Check minimum segments
        if (rows.length < 3) {
          errors.push('At least 3 segments are required to form a polygon.');
        }

        // Parse starting bearing for Internal/Deflection modes
        if (bearingType === 'Internal' || bearingType === 'Deflection') {
          const startingBearingInput = document.getElementById('startingBearing');
          try {
            currentBearing = parseDMS(startingBearingInput.value);
            currentBearing = normalizeBearing(currentBearing);
          } catch (e) {
            startingBearingInput.classList.add('error');
            errors.push(`Starting bearing: ${e.message}`);
          }
        }

        // Parse each segment
        rows.forEach((row, idx) => {
          const bearingInput = row.children[1].firstChild;
          const lengthInput = row.children[2].firstChild;
          const segNum = idx + 1;

          let bearing, length;
          let segmentValid = true;

          // Parse bearing
          try {
            const rawBearing = parseBearingValue(bearingInput.value, bearingType);

            // Calculate absolute bearing based on mode and type
            if (bearingType === 'Internal') {
              if (idx === 0) {
                // First segment uses starting bearing
                bearing = currentBearing;
              } else {
                // Turn by (180 - internal angle) to the right
                // Internal angle is the interior angle of the polygon
                const internalAngle = rawBearing;
                if (internalAngle <= 0 || internalAngle >= 360) {
                  throw new Error(`Internal angle must be between 0° and 360°. Got: ${internalAngle}°`);
                }
                const deflection = 180 - internalAngle;
                currentBearing = normalizeBearing(currentBearing + deflection);
                bearing = currentBearing;
              }
            } else if (bearingType === 'Deflection') {
              if (idx === 0) {
                // First segment: starting bearing + first deflection
                bearing = normalizeBearing(currentBearing + rawBearing);
                currentBearing = bearing;
              } else {
                // Subsequent: add deflection to current bearing
                currentBearing = normalizeBearing(currentBearing + rawBearing);
                bearing = currentBearing;
              }
            } else if (angleInputMode === 'Relative') {
              if (idx === 0) {
                // First segment is absolute
                currentBearing = normalizeBearing(rawBearing);
              } else {
                // Add relative angle to previous bearing
                currentBearing = normalizeBearing(currentBearing + rawBearing);
              }
              bearing = currentBearing;
            } else {
              // Absolute mode
              bearing = normalizeBearing(rawBearing);
            }
          } catch (e) {
            bearingInput.classList.add('error');
            errors.push(`Segment ${segNum} bearing: ${e.message}`);
            segmentValid = false;
          }

          // Parse length
          try {
            length = parseLengthValue(lengthInput.value, inputUnit);
          } catch (e) {
            lengthInput.classList.add('error');
            errors.push(`Segment ${segNum} length: ${e.message}`);
            segmentValid = false;
          }

          if (segmentValid) {
            segments.push({ bearing, length_m: length, index: idx });
          }
        });

        return {
          valid: errors.length === 0 && segments.length === rows.length,
          segments,
          errors
        };
      }

      // ============================================
      // FLIP: Reverse Bearing
      // ============================================

      function flipSegment(row) {
        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const inputField = row.children[1].firstChild;

        try {
          const rawValue = inputField.value.trim();
          let currentDegrees;

          // Parse current value
          if (bearingType === 'Quadrant') {
            currentDegrees = parseQuadrantBearing(rawValue);
          } else if (bearingType === 'Grads') {
            currentDegrees = parseFloat(rawValue) * GRADS_TO_DEGREES;
          } else if (bearingType === 'Internal') {
            // For internal angles, flipping doesn't make sense in the same way
            // We'll flip the resulting direction instead
            currentDegrees = parseFloat(rawValue);
            const flipped = 360 - currentDegrees;
            inputField.value = flipped.toFixed(2);
            recalculate();
            return;
          } else if (bearingType === 'Deflection') {
            // For deflection, negate the angle
            currentDegrees = parseFloat(rawValue);
            inputField.value = (-currentDegrees).toFixed(2);
            recalculate();
            return;
          } else {
            currentDegrees = parseDMS(rawValue);
          }

          // Add 180° and normalize
          const flipped = normalizeBearing(currentDegrees + 180);

          // Format back
          if (bearingType === 'Quadrant') {
            inputField.value = decimalToQuadrant(flipped);
          } else if (bearingType === 'Grads') {
            inputField.value = (flipped / GRADS_TO_DEGREES).toFixed(2);
          } else {
            inputField.value = flipped.toFixed(2);
          }

          inputField.classList.remove('error');
          recalculate();
        } catch (e) {
          inputField.classList.add('error');
        }
      }

      // ============================================
      // MAIN: Recalculation
      // ============================================

      function recalculate() {
        const validationErrorsDiv = document.getElementById('validationErrors');
        const resultsDisplay = document.getElementById('resultsDisplay');

        // Validate and parse
        const result = validateAndParseInputs();

        // Show errors if any
        if (result.errors.length > 0) {
          validationErrorsDiv.innerHTML = `
            <div class="error-box">
              <strong>Please fix the following issues:</strong>
              <ul>
                ${result.errors.map(e => `<li>${e}</li>`).join('')}
              </ul>
            </div>
          `;
          resultsDisplay.innerHTML = '<p style="color:#e74c3c;">Cannot calculate - please fix input errors above.</p>';

          // Clear diagram
          const canvas = document.getElementById('diagramCanvas');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#e74c3c';
          ctx.font = '14px Roboto';
          ctx.textAlign = 'center';
          ctx.fillText('Fix input errors to see diagram', canvas.width / 2, canvas.height / 2);
          return;
        }

        validationErrorsDiv.innerHTML = '';

        // Compute geometry
        const segments = result.segments;
        const points = computeCoordinates(segments);
        const area = computeArea(points);
        const perimeter = computePerimeter(segments);
        const misclosure = computeMisclosure(points);

        // Draw diagram
        drawDiagram(points, misclosure);

        // Generate report
        resultsDisplay.innerHTML = generateResultsReport(area, perimeter, misclosure, segments);
      }

      // ============================================
      // REPORT: Generate Results
      // ============================================

      function generateResultsReport(area, perimeter, misclosure, segments) {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'long',
          year: 'numeric'
        });
        const timeStr = now.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit'
        });

        const bearingType = document.getElementById('bearingType').value;
        const angleInputMode = document.getElementById('angleInputMode').value;
        const inputUnit = document.getElementById('inputUnit').value;
        const planDescription = document.getElementById('planDescription').value.trim();

        const bearingTypeLabels = {
          'WholeCircle': 'Whole Circle Bearings',
          'DecimalDegrees': 'Decimal Degrees',
          'Quadrant': 'Quadrant Bearings',
          'Internal': 'Internal Angles',
          'Deflection': 'Deflection Angles',
          'Grads': 'Grads'
        };

        const areaVals = convertAreaValues(area);
        const perimVals = convertPerimeterValues(perimeter);

        // Closure status
        let closureHtml;
        let closureStatus;
        let accuracyRatio = 'N/A';

        if (misclosure) {
          const misclosureText = `${misclosure.length_m.toFixed(4)} m at bearing ${misclosure.bearing.toFixed(2)}°`;
          accuracyRatio = perimeter > 0 ? `1:${Math.round(perimeter / misclosure.length_m).toLocaleString()}` : 'N/A';
          closureStatus = 'Open (misclosure present)';
          closureHtml = `
            <div class="warning-box no-break">
              <strong>⚠ Polygon Does Not Close</strong><br>
              <div style="margin-top: 6px;">
                <strong>Misclosure:</strong> ${misclosureText}<br>
                <strong>Accuracy Ratio:</strong> ${accuracyRatio}<br>
                <small style="color: #7f8c8d;">Note: The calculated area assumes a straight line closes the gap between the last and first points.</small>
              </div>
            </div>
          `;
        } else {
          closureStatus = 'Closed';
          closureHtml = `
            <div class="print-closed-status no-break">
              <strong>✓ Polygon is Closed</strong><br>
              <small>The traverse closes within acceptable tolerance.</small>
            </div>
          `;
        }

        // Build segment table
        let segmentTableRows = '';
        for (let i = 0; i < segments.length; i++) {
          const seg = segments[i];
          let displayLength;
          switch (inputUnit) {
            case 'DecimalFeet':
              displayLength = (seg.length_m / FEET_TO_METRES).toFixed(3) + ' ft';
              break;
            case 'FeetInches':
              const totalInches = seg.length_m / INCH_TO_METRES;
              const feet = Math.floor(totalInches / 12);
              const inches = (totalInches % 12).toFixed(1);
              displayLength = `${feet}' ${inches}"`;
              break;
            case 'Links':
              displayLength = (seg.length_m / LINK_TO_METRES).toFixed(2) + ' lk';
              break;
            default:
              displayLength = seg.length_m.toFixed(3) + ' m';
          }

          segmentTableRows += `
            <tr>
              <td>${i + 1}</td>
              <td>${seg.bearing.toFixed(2)}°</td>
              <td>${decimalToQuadrant(seg.bearing)}</td>
              <td>${seg.length_m.toFixed(3)}</td>
              <td>${displayLength}</td>
            </tr>
          `;
        }

        // Capture diagram
        const canvas = document.getElementById('diagramCanvas');
        const diagramImage = canvas.toDataURL('image/png');

        // Description section (only if provided)
        const descriptionHtml = planDescription ? `
          <div class="print-description no-break">
            <strong>Description:</strong> ${planDescription}
          </div>
        ` : '';

        return `
          <!-- Professional Report Header -->
          <div class="print-report-header">
            <h1>Area Calculation Report</h1>
            <h2>Survey Traverse Analysis</h2>
          </div>

          <div class="print-meta">
            Generated: ${dateStr} at ${timeStr}
          </div>

          ${descriptionHtml}

          <!-- Key Results Summary Box -->
          <div class="print-summary-box no-break">
            <h4>Summary of Results</h4>
            <div class="print-summary-grid">
              <div class="print-summary-item">
                <span class="print-summary-label">Total Area:</span>
                <span class="print-summary-value">${areaVals.m2}</span>
              </div>
              <div class="print-summary-item">
                <span class="print-summary-label">Area (Hectares):</span>
                <span class="print-summary-value">${areaVals.ha}</span>
              </div>
              <div class="print-summary-item">
                <span class="print-summary-label">Total Perimeter:</span>
                <span class="print-summary-value">${perimVals.m}</span>
              </div>
              <div class="print-summary-item">
                <span class="print-summary-label">Number of Sides:</span>
                <span class="print-summary-value">${segments.length}</span>
              </div>
              <div class="print-summary-item">
                <span class="print-summary-label">Closure Status:</span>
                <span class="print-summary-value">${closureStatus}</span>
              </div>
              <div class="print-summary-item">
                <span class="print-summary-label">Accuracy Ratio:</span>
                <span class="print-summary-value">${accuracyRatio}</span>
              </div>
            </div>
          </div>

          <!-- Survey Diagram -->
          <div class="print-diagram-section no-break">
            <img src="${diagramImage}" alt="Survey Diagram">
            <div class="print-diagram-caption">
              Figure 1: Survey traverse diagram (segment numbers shown)
            </div>
          </div>

          <!-- Closure Status -->
          <h3>Closure Status</h3>
          ${closureHtml}

          <!-- Two Column Layout for Area and Perimeter -->
          <div class="print-two-column no-break">
            <div class="print-column">
              <h3>Calculated Area</h3>
              <ul>
                <li><strong>Square metres:</strong> ${areaVals.m2}</li>
                <li>Square feet: ${areaVals.ft2}</li>
                <li>Hectares: ${areaVals.ha}</li>
                <li>Acres: ${areaVals.acres}</li>
                <li>Perches: ${areaVals.perches}</li>
                <li>Roods: ${areaVals.roods}</li>
              </ul>
            </div>
            <div class="print-column">
              <h3>Calculated Perimeter</h3>
              <ul>
                <li><strong>Metres:</strong> ${perimVals.m}</li>
                <li>Feet: ${perimVals.ft}</li>
                <li>Links: ${perimVals.links}</li>
                <li>Kilometres: ${perimVals.km}</li>
                <li>Miles: ${perimVals.miles}</li>
              </ul>
            </div>
          </div>

          <!-- Segment Details Table -->
          <h3>Traverse Schedule</h3>
          <table class="no-break">
            <thead>
              <tr>
                <th>Seg</th>
                <th>Bearing (°)</th>
                <th>Quadrant</th>
                <th>Length (m)</th>
                <th>Length (${inputUnit})</th>
              </tr>
            </thead>
            <tbody>
              ${segmentTableRows}
            </tbody>
          </table>

          <!-- Methodology Note -->
          <div class="no-break" style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em;">
            <strong>Calculation Method:</strong><br>
            <ul style="margin: 5px 0 0 20px; padding: 0;">
              <li>Input format: ${bearingTypeLabels[bearingType] || bearingType} (${angleInputMode} mode)</li>
              <li>Distance units: ${inputUnit}</li>
              <li>Coordinate system: Local grid (origin at first point)</li>
              <li>Area calculation: Shoelace formula (Surveyor's formula)</li>
            </ul>
          </div>

          <!-- Footer -->
          <div class="print-footer">
            <div class="print-footer-content">
              <span>Area Calculator Tool</span>
              <span>Tom Phillips © ${new Date().getFullYear()}</span>
              <span>Page 1</span>
            </div>
          </div>
        `;
      }

      // ============================================
      // SAVE & PRINT
      // ============================================

      document.getElementById('saveResultsBtn').addEventListener('click', () => {
        const reportContent = document.getElementById('resultsDisplay').innerText +
          '\n\nPlan Description:\n' + document.getElementById('planDescription').value;
        const blob = new Blob([reportContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Area_Calculator_Report.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      document.getElementById('printPreviewBtn').addEventListener('click', () => {
        window.print();
      });

      // ============================================
      // EVENT LISTENERS
      // ============================================

      document.getElementById('setSegmentsBtn').addEventListener('click', () => {
        const num = parseInt(document.getElementById('numSegments').value);
        if (isNaN(num) || num < 3) {
          alert('Please enter at least 3 segments.');
          return;
        }
        if (num > 100) {
          alert('Maximum 100 segments allowed.');
          return;
        }
        clearSegmentsTable();
        for (let i = 0; i < num; i++) {
          addSegmentRow();
        }
        updateFormatHints();
        liveUpdateDiagram(); // Draw initial diagram
      });

      document.getElementById('addSegmentBtn').addEventListener('click', () => {
        addSegmentRow();
        triggerLiveUpdate();
      });

      document.getElementById('recalcBtn').addEventListener('click', recalculate);

      // Starting bearing input - live update for Internal/Deflection modes
      document.getElementById('startingBearing').addEventListener('input', () => {
        triggerLiveUpdate();
      });

      // Update hints and diagram when settings change
      document.getElementById('bearingType').addEventListener('change', () => {
        updateFormatHints();
        triggerLiveUpdate();
      });
      document.getElementById('angleInputMode').addEventListener('change', () => {
        updateFormatHints();
        triggerLiveUpdate();
      });
      document.getElementById('inputUnit').addEventListener('change', () => {
        updateFormatHints();
        triggerLiveUpdate();
      });

      // ============================================
      // INITIALIZATION
      // ============================================

      window.onload = () => {
        document.getElementById('angleInputMode').value = 'Absolute';
        document.getElementById('bearingType').value = 'WholeCircle';
        updateFormatHints();
        document.getElementById('setSegmentsBtn').click();
        // Initial diagram is drawn by setSegmentsBtn click handler
      };

    })();
  </script>
</body>
</html>
